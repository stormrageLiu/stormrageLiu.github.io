<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Package.json 文件扫盲</title>
      <link href="/2024/08/01/2024-08-01-Package.json%20%E6%96%87%E4%BB%B6%E6%89%AB%E7%9B%B2/"/>
      <url>/2024/08/01/2024-08-01-Package.json%20%E6%96%87%E4%BB%B6%E6%89%AB%E7%9B%B2/</url>
      
        <content type="html"><![CDATA[<p><code>package.json</code> 文件是 Node.js 项目中的一个核心配置文件，它包含了项目的元数据和依赖信息。以下是 <code>package.json</code> 文件中一些常见字段的解释：</p><ol><li><strong><code>name</code></strong>: 项目的名称。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"name": "my-project"</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>version</code></strong>: 项目的版本号，遵循语义化版本（Semantic Versioning）规范。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"version": "1.0.0"</span><br></pre></td></tr></table></figure><ol start="3"><li><strong><code>description</code></strong>: 项目的简短描述。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"description": "A sample project"</span><br></pre></td></tr></table></figure><ol start="4"><li><strong><code>main</code></strong>: 项目的入口文件，通常是 <code>index.js</code> 或 <code>main.js</code>。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"main": "index.js"</span><br></pre></td></tr></table></figure><ol start="5"><li><strong><code>scripts</code></strong>: 定义项目中可运行的脚本命令，例如 <code>npm start</code>、<code>npm test</code> 等。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "node index.js",</span><br><span class="line">  "build": "gulp build"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li><strong><code>dependencies</code></strong>: 项目运行时所依赖的包，这些包会在生产环境中使用。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "express": "^4.17.1",</span><br><span class="line">  "lodash": "^4.17.21"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><strong><code>devDependencies</code></strong>: 开发环境中所依赖的包，这些包只在开发过程中使用，不会在生产环境中安装。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">  "gulp": "^4.0.2",</span><br><span class="line">  "typescript": "^4.3.5"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="8"><li><strong><code>peerDependencies</code></strong>: 指定项目所需的依赖版本，但不会自动安装，通常用于插件或库。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"peerDependencies": &#123;</span><br><span class="line">  "react": "^17.0.2"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li><strong><code>keywords</code></strong>: 项目的关键词，有助于在 npm 上搜索项目。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"keywords": ["sample", "project", "node"]</span><br></pre></td></tr></table></figure><ol start="10"><li><strong><code>author</code></strong>: 项目的作者信息。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"author": "John Doe &lt;john.doe@example.com&gt;"</span><br></pre></td></tr></table></figure><ol start="11"><li><strong><code>license</code></strong>: 项目的许可证类型。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"license": "MIT"</span><br></pre></td></tr></table></figure><ol start="12"><li><strong><code>repository</code></strong>: 项目的代码仓库地址。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"repository": &#123;</span><br><span class="line">  "type": "git",</span><br><span class="line">  "url": "https://github.com/username/repo.git"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="13"><li><strong><code>bugs</code></strong>: 项目的问题追踪地址。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"bugs": &#123;</span><br><span class="line">  "url": "https://github.com/username/repo/issues"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="14"><li><strong><code>homepage</code></strong>: 项目的官方网站或文档地址。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"homepage": "https://example.com/my-project"</span><br></pre></td></tr></table></figure><p><code>package.json</code> 文件可以通过 <code>npm init</code> 命令生成，也可以手动编辑。它是 Node.js 项目管理和依赖管理的基础，确保项目能够正确地安装依赖、运行脚本和发布到 npm 仓库。</p><h2 id="依赖包中的特殊符号">依赖包中的特殊符号</h2><p>在 <code>package.json</code> 文件中，版本号前面的特殊字符用于指定依赖包的版本范围。这些字符包括 <code>^</code>、<code>~</code> 和 <code>@</code>，它们各自有不同的含义：</p><h3 id="无符号版本">无符号版本</h3><p>直接指定版本号（如 <code>&quot;express&quot;: &quot;4.17.1&quot;</code>）表示精确安装指定的版本，不会安装任何其他版本。</p><h3 id="符号"><code>^</code> 符号</h3><p><code>^</code> 符号表示“兼容版本”。当你在 <code>package.json</code> 中看到 <code>&quot;adm-zip&quot;: &quot;^0.5.12&quot;</code> 这样的条目时，它意味着 npm 可以安装 <code>0.5.x</code> 版本的最新版本，但不会安装 <code>0.6.0</code> 或更高版本。例如，如果最新的 <code>adm-zip</code> 版本是 <code>0.5.15</code>，那么 <code>npm install</code> 会安装 <code>0.5.15</code>。但是，如果最新的版本是 <code>0.6.0</code>，则不会安装它。</p><h3 id="符号-2"><code>~</code> 符号</h3><p><code>~</code> 符号表示“近似版本”。当你看到 <code>&quot;builtin-modules&quot;: &quot;~3.1.0&quot;</code> 这样的条目时，它意味着 npm 可以安装 <code>3.1.x</code> 版本的最新版本，但不会安装 <code>3.2.0</code> 或更高版本。例如，如果最新的 <code>builtin-modules</code> 版本是 <code>3.1.4</code>，那么 <code>npm install</code> 会安装 <code>3.1.4</code>。但是，如果最新的版本是 <code>3.2.0</code>，则不会安装它。</p><h3 id="符号-3"><code>@</code> 符号</h3><p><code>@</code> 符号通常用于指定 npm 包的名称范围。当你看到 <code>&quot;@o4e/kcpconn&quot;: &quot;3.1.48&quot;</code> 这样的条目时，它表示这是一个带有命名空间的包。<code>@o4e</code> 是这个包的命名空间，<code>kcpconn</code> 是包的实际名称。这种命名方式允许在 npm 上发布具有相同名称但属于不同组织或作者的包，从而避免名称冲突。</p><p>总结来说，这些符号帮助你更灵活地管理依赖包的版本，确保你的项目在不同的环境中保持一致性和兼容性。</p><h3 id="符号-4"><code>*</code> 符号</h3><p><code>*</code> 符号表示任何版本。例如，<code>&quot;express&quot;: &quot;*&quot;</code> 表示可以安装任何版本的 <code>express</code>。</p><h3 id="符号-5"><code>&gt;</code> 符号</h3><p><code>&gt;</code> 符号表示大于某个版本。例如，<code>&quot;express&quot;: &quot;&gt;4.17.1&quot;</code> 表示安装任何高于 <code>4.17.1</code> 的版本。</p><h3 id="符号-6"><code>&lt;</code> 符号</h3><p><code>&lt;</code> 符号表示小于某个版本。例如，<code>&quot;express&quot;: &quot;&lt;4.17.1&quot;</code> 表示安装任何低于 <code>4.17.1</code> 的版本。</p><h3 id="符号-7"><code>&gt;=</code> 符号</h3><p><code>&gt;=</code> 符号表示大于或等于某个版本。例如，<code>&quot;express&quot;: &quot;&gt;=4.17.1&quot;</code> 表示安装 <code>4.17.1</code> 或更高版本。</p><h3 id="符号-8"><code>&lt;=</code> 符号</h3><p><code>&lt;=</code> 符号表示小于或等于某个版本。例如，<code>&quot;express&quot;: &quot;&lt;=4.17.1&quot;</code> 表示安装 <code>4.17.1</code> 或更低版本。</p><h3 id="组合符号">组合符号</h3><p>可以组合使用这些符号来创建更复杂的版本范围。例如，<code>&quot;express&quot;: &quot;&gt;=4.17.0 &lt;5.0.0&quot;</code> 表示安装 <code>4.17.x</code> 版本，但不安装 <code>5.x</code> 版本。</p><h3 id="符号-9"><code>-</code> 符号</h3><p><code>-</code> 符号表示版本区间。例如，<code>&quot;express&quot;: &quot;4.17.0 - 4.17.3&quot;</code> 表示安装 <code>4.17.0</code> 到 <code>4.17.3</code> 之间的版本。</p><h3 id="符号-10"><code>||</code> 符号</h3><p><code>||</code> 符号表示逻辑或。例如，<code>&quot;express&quot;: &quot;4.17.1 || 4.17.3&quot;</code> 表示可以安装 <code>4.17.1</code> 或 <code>4.17.3</code> 版本。</p><h3 id="预发行版本（alpha-beta-rc）">预发行版本（alpha, beta, rc）</h3><p>你还可以指定预发行版本，例如 <code>&quot;package&quot;: &quot;1.0.0-alpha.1&quot;</code>。这些版本通常用于发布候选版本或测试版。</p><p>总结起来，这些符号和方式为供了灵活性，可以根据项目的需求来管理依赖包的版本。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript 不支持 CommonJS 模块系统</title>
      <link href="/2024/07/31/2024-07-31-TypeScript%20%E4%B8%8D%E6%94%AF%E6%8C%81%20CommonJS%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/07/31/2024-07-31-TypeScript%20%E4%B8%8D%E6%94%AF%E6%8C%81%20CommonJS%20%E6%A8%A1%E5%9D%97%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p><code>ts(1259)</code>错误。尝试从一个使用 CommonJS 模块系统（使用 <code>export =</code> 语法）的模块中进行默认导入，而 TypeScript 默认情况下不支持这种导入方式。</p><h4 id="解决方案：">解决方案：</h4><ol><li><p><strong>启用 **</strong><code>esModuleInterop</code>*<strong>* 标志</strong>：在你的 <code>tsconfig.json</code> 文件中启用 <code>esModuleInterop</code> 标志。这个标志会改变 TypeScript 处理 CommonJS 模块的方式，使其支持默认导入。</p><p>在你的 <code>tsconfig.json</code> 文件中添加或修改以下配置：</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;</span><br><span class="line">    <span class="string">"esModuleInterop"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 其他配置项...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>修改导入语句</strong>：确保你的导入语句正确。对于 <code>upath</code> 模块，你可以这样导入：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">"upath"</span>;</span><br></pre></td></tr></table></figure><pre><code>如果 `upath` 模块本身是 CommonJS 模块，并且使用了 `export =` 语法，那么启用 `esModuleInterop` 标志后，你应该能够正常导入它。</code></pre><ol start="3"><li><strong>重新编译项目</strong>：保存 <code>tsconfig.json</code> 文件并重新编译你的项目。</li></ol><p>如果还有问题，可以尝试以下额外的步骤：</p><ol><li><strong>检查 **</strong><code>upath</code>*<strong>* 模块的类型定义</strong>：确保 <code>upath</code> 模块的类型定义文件（<code>.d.ts</code> 文件）正确地使用了 <code>export =</code> 语法。如果类型定义文件不正确，你可能需要手动修复它或寻找一个正确的类型定义文件。</li><li><strong>使用 **</strong><code>require</code>*<strong>* 语法</strong>：如果上述方法都不起作用，你可以尝试使用 CommonJS 的 <code>require</code> 语法来导入模块：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"upath"</span>);</span><br></pre></td></tr></table></figure><pre><code>这种方法不需要启用 `esModuleInterop` 标志，但会失去 TypeScript 的模块系统的一些优势。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins升级与定期备份</title>
      <link href="/2023/10/11/2023-10-11-Jenkins%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BD/"/>
      <url>/2023/10/11/2023-10-11-Jenkins%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AE%9A%E6%9C%9F%E5%A4%87%E4%BB%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="升级版本的必要性">升级版本的必要性</h2><p>Jenkins 的版本会有很多，从<a href="https://www.jenkins.io/zh/download/lts/" target="_blank" rel="noopener">官网 LTS 路线中有详细说明</a>。它们会每周更新 1 个版本。而每 12 周会从中选择一个相对稳定的版本作为 LTS 版本。 而这个版本的作为基础开始进行后续维护。后续维护只会包括主干分支上最佳 bug 解决方案进行更新。</p><p>所以，作为生产环境来说，选择一个合适的 LTS 版本进行即可， 并不需要每周都跟随 Jenkins 社区进行版本更新</p><h2 id="升级版本与-Java-版本的兼容性">升级版本与 Java 版本的兼容性</h2><ul><li>LTS-2.361.1,开始最低要求 Java11，可适配 Java17</li><li>LTS-2.346.1,开始最低要求 Java8，可适配 Java11 、Java17</li><li>LTS-2.164.1,开始最低要求 Java8，可适配 Java11</li></ul><h2 id="定期备份">定期备份</h2><h4 id="备份插件-ThinBackup">备份插件 ThinBackup</h4><ol><li>在 Jenkins 中安装 thinbackup 插件</li><li>安装完成后再系统底部找到 thinbackup 的配置入口</li><li>根据配置设置好</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Backup directory  设置备份的目录，注意运行 jenkins 的目录要对它有写的权限。</span><br><span class="line">Backup schedule <span class="keyword">for</span> full backups 设置定时任务，Example:</span><br><span class="line"><span class="number">0</span> <span class="number">12</span> * * <span class="number">1</span><span class="number">-5</span>Executes on <span class="number">12</span>:<span class="number">00</span> every weekday (Mo-Fr)</span><br><span class="line">Backup schedule <span class="keyword">for</span> differential backups设置差异化备份的计划，也就是增量备份，仅仅存储上一次完整备份的之后的更改部分。 对于增量备份，我们必须要有一个完整备份。</span><br><span class="line">Max <span class="built_in">number</span> of backup sets 备份的最大数量数，默认为 <span class="number">-1.</span>表示无限制。</span><br><span class="line">Files excluded <span class="keyword">from</span> backup (regular expression) 备份需要排除的目录。</span><br><span class="line">Wait until Jenkins/Hudson is idle to perform a backup  等待 jenkins 进入“Quiet Mode”(安静模式)的时候去进行备份。安静模式期间不处理任何任务。 建议勾选。</span><br><span class="line"></span><br><span class="line">Force Jenkins to quiet mode after specified minutes  ： 最长等待进入安静模式的时间，当超过这个时间，就会强制进入 安静模式。</span><br><span class="line"></span><br><span class="line">Backup build results 备份构建的结果，这个可能会产生大量的数据。占用磁盘会比较大。</span><br><span class="line">Backup build archive 只有勾选了 Backup build results 才会出现这个选项。备份存档，</span><br><span class="line">Backup only builds marked to keep  如果勾选此项，只备份被标记为 <span class="string">`Keep this build forever`</span> 的上的构建结果。只有勾选了 Backup build results 才会出现这个选项。</span><br><span class="line"></span><br><span class="line">Backup <span class="string">'userContent'</span> folder  如果启用该备份，userContent 目录($JENKINS_HOME/userContent)将会备份。 如果有软链接部分，不能备份该内容。</span><br><span class="line">Backup next build <span class="built_in">number</span> file   如果启用该项，则 nextBuildNumber  也会进行备份。</span><br><span class="line">Backup plugins archives  启用该项的话，会进行备份插件存档。</span><br><span class="line">Backup additional files  备份特定的文件，可以通过正则进行匹配。</span><br><span class="line">Clean up differential backups  如果启用了该选项的话，在执行完整备份的时候，会删除差异化备份。</span><br><span class="line">Move old backups to ZIP files  将老的备份文件进行压缩。</span><br></pre></td></tr></table></figure><ol start="4"><li>为了稳妥起见，还可以配置一个 git 仓库。将备份的文件 Push 到 Git 仓库。在 jenkins 设置一个定时任务，用于定期执行一个 Push 的命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入备份目录</span></span><br><span class="line">cd /Users/jinglong/job/backup || exit 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化 git 仓库（如果尚未初始化）</span></span><br><span class="line">if [ ! -d ".git" ]; then</span><br><span class="line">    git init</span><br><span class="line">    git remote add origin http://xxx.xxx.xxx.xxx:xxxx/git/backup.git</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有文件到 git</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交更改</span></span><br><span class="line">git commit -m "Automated backup commit on $(date)"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到远程仓库</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 日常填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cocos Creator中的寻路算法实践：A*与RVO2动态避障</title>
      <link href="/2023/04/21/2023-04-21-Cocos%20Creator%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%EF%BC%9AA*%E4%B8%8ERVO2%E5%8A%A8%E6%80%81%E9%81%BF%E9%9A%9C/"/>
      <url>/2023/04/21/2023-04-21-Cocos%20Creator%E4%B8%AD%E7%9A%84%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95%E5%AE%9E%E8%B7%B5%EF%BC%9AA*%E4%B8%8ERVO2%E5%8A%A8%E6%80%81%E9%81%BF%E9%9A%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="一、寻路算法基础">一、寻路算法基础</h2><p>在游戏开发中，寻路算法是实现智能体自主移动的核心技术。根据应用场景的不同，我们主要采用两类算法：</p><h3 id="1-1-全局路径规划（A-算法）">1.1 全局路径规划（A*算法）</h3><h4 id="核心原理">核心原理</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AStarNode &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    g: <span class="built_in">number</span>;  <span class="comment">// 起点到当前节点的实际成本</span></span><br><span class="line">    h: <span class="built_in">number</span>;  <span class="comment">// 当前节点到终点的预估成本</span></span><br><span class="line">    f: <span class="built_in">number</span>;  <span class="comment">// 总评估成本（g + h）</span></span><br><span class="line">    parent: AStarNode | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="comment">// ...初始化其他属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法流程</p><p>初始化开放列表(OpenList)和关闭列表(ClosedList)将起点加入开放列表循环处理：</p><p>选取 F 值最小的节点到达终点则回溯路径处理相邻节点（8 方向或 4 方向）<br>路径回溯</p><h3 id="1-2-动态避障（RVO2-算法）">1.2 动态避障（RVO2 算法）</h3><p>核心特性</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RVOVelocity &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    add(other: RVOVelocity): RVOVelocity &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RVOVelocity(<span class="keyword">this</span>.x + other.x, <span class="keyword">this</span>.y + other.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> RVOAvoidance &#123;</span><br><span class="line">    <span class="keyword">static</span> computeNewVelocity(current: RVOVelocity,</span><br><span class="line">                             neighbors: RVOVelocity[]): RVOVelocity &#123;</span><br><span class="line">        <span class="comment">// 实现速度障碍计算逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、Cocos-Creator-实现方案">二、Cocos Creator 实现方案</h2><h3 id="2-1-A-算法实现">2.1 A*算法实现</h3><p>地图初始化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAP_SIZE = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">const</span> grid: <span class="built_in">number</span>[][] = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机障碍地图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; MAP_SIZE; x++) &#123;</span><br><span class="line">    grid[x] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; MAP_SIZE; y++) &#123;</span><br><span class="line">        grid[x][y] = <span class="built_in">Math</span>.random() &gt; <span class="number">0.8</span> ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// 20%障碍率</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启发式函数选择</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 曼哈顿距离（适合4方向移动）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">manhattanDistance</span>(<span class="params">a: cc.Vec2, b: cc.Vec2</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.abs(a.x - b.x) + <span class="built_in">Math</span>.abs(a.y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧几里得距离（适合任意方向移动）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">euclideanDistance</span>(<span class="params">a: cc.Vec2, b: cc.Vec2</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="built_in">Math</span>.pow(a.x - b.x, <span class="number">2</span>) + <span class="built_in">Math</span>.pow(a.y - b.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 RVO2 集成实现<br>智能体类设计</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RVOActor <span class="keyword">extends</span> cc.Component &#123;</span><br><span class="line">    <span class="meta">@property</span>(cc.Float)</span><br><span class="line">    maxSpeed: <span class="built_in">number</span> = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@property</span>(cc.Float)</span><br><span class="line">    neighborDist: <span class="built_in">number</span> = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    velocity: cc.Vec2 = cc.Vec2.ZERO;</span><br><span class="line">    desiredVelocity: cc.Vec2 = cc.Vec2.ZERO;</span><br><span class="line"></span><br><span class="line">    update(dt: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> neighbors = <span class="keyword">this</span>.getNeighbors();</span><br><span class="line">        <span class="keyword">this</span>.velocity = RVOCalculator.calculate(</span><br><span class="line">            <span class="keyword">this</span>.node.position,</span><br><span class="line">            <span class="keyword">this</span>.desiredVelocity,</span><br><span class="line">            neighbors</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">this</span>.node.position = <span class="keyword">this</span>.node.position.add(<span class="keyword">this</span>.velocity.mul(dt));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速度障碍计算</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RVOCalculator &#123;</span><br><span class="line">    <span class="keyword">static</span> calculate(position: cc.Vec2,</span><br><span class="line">                    desiredVel: cc.Vec2,</span><br><span class="line">                    neighbors: RVOActor[]): cc.Vec2 &#123;</span><br><span class="line">        <span class="keyword">let</span> newVel = desiredVel.clone();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> neighbor of neighbors) &#123;</span><br><span class="line">            <span class="keyword">const</span> relativePos = neighbor.node.position.sub(position);</span><br><span class="line">            <span class="keyword">const</span> dist = relativePos.mag();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dist &lt; <span class="keyword">this</span>.neighborDist) &#123;</span><br><span class="line">                <span class="keyword">const</span> avoidance = relativePos.normalize().negate();</span><br><span class="line">                newVel = newVel.add(avoidance.mul(<span class="number">0.1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newVel.clampf(<span class="number">0</span>, <span class="keyword">this</span>.maxSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、性能优化策略">三、性能优化策略</h2><h3 id="3-1-A-优化方案">3.1 A*优化方案</h3><p>分层寻路：将大地图分割为多个区域跳跃点优化：利用 JPS(Jump Point Search)算法动态更新：增量式路径更新</p><h3 id="3-2-RVO2-优化方案">3.2 RVO2 优化方案</h3><p>空间划分：使用四叉树管理智能体 LOD 控制：根据距离调整计算精度异步计算：分帧处理避障逻辑</p><h2 id="四、实战应用场景">四、实战应用场景</h2><h3 id="4-1-MMORPG-中的-NPC-移动">4.1 MMORPG 中的 NPC 移动</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合使用A*和RVO2</span></span><br><span class="line">npc.scheduleOnce(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> path = AStar.findPath(currentPos, targetPos);</span><br><span class="line">    <span class="keyword">this</span>.followPath(path);</span><br><span class="line">&#125;, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h2 id="五、其他">五、其他</h2><p>对于简单的 NPC 使用 A*和 RVO2 可能是不错的选择，但是例如 RTS 中的智能群体，就会出现每个单位单独计算偏移路径，大规模单位时性能损耗高。而且一旦增加障碍物或者敌人，无法响应实时环境变化。<br>这个时候可以考虑</p><h4 id="流场寻路（Flow-Field-Pathfinding）">流场寻路（Flow Field Pathfinding）</h4><p>为整个地图生成统一的矢量场，所有单位共享方向数据，避免重复计算，计算复杂度从 O(N)降至 O(1)，支持大规模单位流畅移动。流场算法相比传统 A*性能会有大幅提升大约 70%</p><p>实现步骤：</p><ul><li>生成热度图（Heatmap）：通过 Wavefront 算法计算每个网格到目标的最短距离。</li><li>生成矢量场（Vector Field）：根据相邻网格距离差计算移动方向向量，归一化后形成流场。</li><li>单位移动：每个单位根据当前位置的矢量方向移动，而非独立寻路</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 流场寻路示例</span></span><br><span class="line"><span class="keyword">const</span> flowField = generateFlowField(targetPos);</span><br><span class="line">units.forEach(<span class="function"><span class="params">unit</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> direction = flowField.getVector(unit.position);</span><br><span class="line">   unit.move(direction.normalize() * speed);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 寻路算法 </tag>
            
            <tag> Cocos Creator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何处理Git中已经Push完的一次提交</title>
      <link href="/2022/07/12/2022-07-12-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Git%E4%B8%AD%E5%B7%B2%E7%BB%8FPush%E5%AE%8C%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4/"/>
      <url>/2022/07/12/2022-07-12-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Git%E4%B8%AD%E5%B7%B2%E7%BB%8FPush%E5%AE%8C%E7%9A%84%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="常见情况">常见情况</h2><p>git 在设计中，当然希望所有开发者都严格按照分支管理策略来作工作，但是有的时候，也会出现某个中间的 <code>Commit</code>出现了问题需要被删掉的情况</p><p>比如有一个一下的提交记录。且都 Push 到远程分支了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提交<span class="number">1</span>: 修改联盟列表 c8220e0</span><br><span class="line">提交<span class="number">2</span>: 增加联盟礼物表现 <span class="number">6</span>d3f6fc</span><br><span class="line">提交<span class="number">3</span>: 增加联盟活动红点 <span class="number">78</span>c6775</span><br><span class="line">提交<span class="number">4</span>: 修改联盟挑战赛的首页弹窗逻辑 <span class="number">345</span>df26</span><br></pre></td></tr></table></figure><p>其中提交 2，由于疏忽导致了一个特效播放的 Bug，那这个 commit 是需要被丢弃了。而另外 3 个提交还需要保留。</p><h2 id="处理分析">处理分析</h2><h4 id="使用-git-reset（最不推荐）">使用 git reset（最不推荐）</h4><p>这个是解决不了问题的，比如直接执行</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset <span class="number">6</span>d3f6fc^  # 回退到提交<span class="number">2</span>前</span><br><span class="line">git push -f # 强制推送,</span><br></pre></td></tr></table></figure><p>那么就会将本来需要保留的提交 3、4 都弄没了。 后续还需要额外的找回。得不偿失</p><h4 id="使用-git-revert">使用 git revert</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert <span class="number">6</span>d3f6fc   # 生成反向提交</span><br><span class="line">git push  # 常规推送,</span><br></pre></td></tr></table></figure><p>这个个操作命令是生成反向提交，其实就是相当于，原始分支：1 → 2 → 3 → 4 变为 现在：1 → 2 → 3 → 4 → [反向 2]<br>这样会导致对整体的 git 分支上多出来一条增加一个重复的代码记录。好处是保护了现场，完整保留故障开发轨迹</p><h4 id="使用-git-rebase">使用 git rebase</h4><ol><li><p>找到需要丢弃的提交的上一次提交的 log，这里要丢弃提交， 也就是找到 提交 1: 修改联盟列表 c8220e0</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i c8220e0</span><br></pre></td></tr></table></figure></li><li><p>进入交互 rebase 界面</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pick <span class="number">6</span>d3f6fc 增加联盟礼物表现</span><br><span class="line">pick <span class="number">78</span>c6775 增加联盟活动红点</span><br><span class="line">pick <span class="number">345</span>df26 修改联盟挑战赛的首页弹窗逻辑</span><br></pre></td></tr></table></figure></li><li><p>这个界面是 vi 编辑界面，用 i 进入编辑模式后，将要删除的 commit 行前面的 pick 改为 drop，然后退出编辑模式，wq 保存退出,如果剩余的提交有冲突，还会提示解决冲突</p></li><li><p><code>git push -f # 强制推送</code></p></li></ol><h2 id="其他记录">其他记录</h2><p>处理删除一些未跟踪的文件</p><ol><li>只列出要删除的文件，不实际操作<ul><li>git clean -nd</li></ul></li><li>真实执行（删除未跟踪文件，保留目录）<ul><li>git clean -df</li></ul></li><li>包含被忽略的文件（如 node_modules/）<ul><li>git clean -xdf</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tilemap与世界地图</title>
      <link href="/2022/03/02/2022-03-02-Tilemap%E4%B8%8E%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE/"/>
      <url>/2022/03/02/2022-03-02-Tilemap%E4%B8%8E%E4%B8%96%E7%95%8C%E5%9C%B0%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>在 2D 游戏开发中，构建广阔的世界地图往往面临资源管理复杂、渲染效率低下等问题。Tilemap（瓦片地图）技术通过将地图拆解为可复用的“瓦片”，实现了高效的地图设计与动态加载</p><h2 id="Tilemap-的核心概念">Tilemap 的核心概念</h2><p>Tilemap 是一种将地图分解为网格状瓦片的技术，每个瓦片对应一个图像资源（如草地、水域、山脉），通过拼接形成复杂地形。其核心组件包括：</p><ul><li>Grid：定义地图的网格布局；</li><li>Tile Palette：瓦片资源库，支持快速拖拽绘制；</li><li>图层系统：支持分层管理地形、装饰物和碰撞体</li></ul><h2 id="Tilemap-优势">Tilemap 优势</h2><ul><li>高效渲染：仅加载可视区域瓦片，降低内存占用；</li><li>灵活编辑：支持动态修改地形，快速迭代地图设计；</li><li>跨平台兼容：适配 Unity、Cocos Creator 等主流引擎</li></ul><h2 id="在-Cocos-中的应用">在 Cocos 中的应用</h2><p>使用 Tiled Map Editor 设计地图，导出为.tmx 或.json 格式。</p><p>在这里新版本的 CocosCreator 提供了 TiledMap 组件可以直接进行绑定资源。这个不多介绍了。</p><p>而还有一个节省加载资源的办法是将 .tmx 的文件转换程二进制文件，然后在代码中进行解析。然后可以解析这个份二进制数据得到一个按层分布的格子坐标。有了这个坐标就可以得到 tile 上标记的关键点需要刷上的图层</p><h3 id="解析后的数据结构：">解析后的数据结构：</h3><p><code>_terrainDataByIdx[i][nc][nr] = v;</code></p><h3 id="tmx-转二进制的大致过程">tmx 转二进制的大致过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">hacker.ExportXmlToBin(</span><br><span class="line">                Path.Combine(folderName, &quot;NUSA20250120.tmx&quot;),</span><br><span class="line">                Path.Combine(outputName, &quot;NUSA20250120.bin&quot;),</span><br><span class="line">                &quot;deco&quot;, &quot;barrier&quot;</span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">public void ExportXmlToBin(string xmlFile, string binFile, params string[] names)</span><br><span class="line">&#123;</span><br><span class="line">   XmlDocument xml &#x3D; new XmlDocument();</span><br><span class="line">   xml.Load(xmlFile);</span><br><span class="line"></span><br><span class="line">   MemoryStream stream &#x3D; new MemoryStream();</span><br><span class="line"></span><br><span class="line">   for (int i &#x3D; 0; i &lt; names.Length; i++)</span><br><span class="line">   &#123;</span><br><span class="line">         string name &#x3D; names[i];</span><br><span class="line">         string[] tiles &#x3D; GetLayerTiles(xml, name);</span><br><span class="line">         ExportBinData(stream, tiles);</span><br><span class="line">   &#125;</span><br><span class="line">   stream.Position &#x3D; 0;</span><br><span class="line">   byte[] bytes &#x3D; new byte[stream.Length];</span><br><span class="line">   stream.Read(bytes, 0, bytes.Length);</span><br><span class="line">   stream.Close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   StreamWriter writer &#x3D; new StreamWriter(binFile, false);</span><br><span class="line">   writer.BaseStream.Write(bytes, 0, bytes.Length);</span><br><span class="line">   writer.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态视野的加载">动态视野的加载</h3><p>一个世界地图足够大的情况，如果一次性刷完，肯定是不合理的。 对于客户端来说，其实只需要知道表现当前视野范围内（实际会稍微扩大一点范围来增加玩家体验）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> checkPosInViewport(x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, hPadding: <span class="built_in">number</span> = <span class="number">160</span>, vPadding: <span class="built_in">number</span> = <span class="number">160</span>): <span class="built_in">boolean</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">let</span> vw: <span class="built_in">number</span> = cc.winSize.width;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (PlatformCore.Instance.isLandscape()) vw = <span class="keyword">this</span>.getLandscapeWidth();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> vh: <span class="built_in">number</span> = cc.winSize.height;</span><br><span class="line">   <span class="keyword">let</span> vx: <span class="built_in">number</span> = <span class="keyword">this</span>.camera.node.x;</span><br><span class="line">   <span class="keyword">let</span> vy: <span class="built_in">number</span> = <span class="keyword">this</span>.camera.node.y;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将可视范围额外算大一点</span></span><br><span class="line">   vw += hPadding * <span class="number">2</span>;</span><br><span class="line">   vh += vPadding * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//考虑缩放 &lt;---</span></span><br><span class="line">   vw /= <span class="keyword">this</span>.camera.zoomRatio;</span><br><span class="line">   vh /= <span class="keyword">this</span>.camera.zoomRatio;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> left: <span class="built_in">number</span> = vx - vw / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">let</span> right: <span class="built_in">number</span> = vx + vw / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">let</span> top: <span class="built_in">number</span> = vy + vh / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">let</span> bottom: <span class="built_in">number</span> = vy - vh / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (x &lt; left) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (y &gt; top) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; bottom) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="世界地图中的额外个体">世界地图中的额外个体</h3><p>世界地图中不可能只存在一些由美术刷好的样子。比如还会定期出现一些宝箱，或者由服务器刷出来的怪物。玩家的城堡会由最开始设计的 2<em>2，通过设计变成 4</em>4。 那这个时候其实很简单，只需要在每个更新地块的时候，判断一下当前的位置上是否有遮挡，移除掉地块层上对应的显示对象即可</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tilemap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 重签名流程</title>
      <link href="/2021/01/15/2021-01-15-iOS%20%E9%87%8D%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B/"/>
      <url>/2021/01/15/2021-01-15-iOS%20%E9%87%8D%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS-的签名机制">iOS 的签名机制</h2><h3 id="简单机制">简单机制</h3><p>这里会用到非对称加密，就是比如很经典的 RSA 加密算法，但篇幅有限，这里主要说一下苹果现在对 App 的加密流程是什么样的，之后再写介绍 RSA 的是如何实现非对称加密的。</p><p>非对称加密，最简单的可以做成：所有的 iOS 系统都内置一个公钥，App Store 的后台上存放一个私钥。App Store 后会通过秘钥对所有上传的 App 进行签名，当在 iPhone 上安装时，再用系统内置的公钥验证这个签名。</p><p><strong>但是</strong>，这样并不能符合苹果和广大开发者的需求！</p><p>比如，开发者需要真机调试时，是不可能都通过上传应用商店来做的。而苹果也不能放开 iOS 的生态控制，让无签名的应用随意安装。所以，双层签名的模式出现了。</p><h3 id="双层签名">双层签名</h3><p>为了解决的这个问题， 苹果公司将 Mac 这个角色加入进来了，同时还增加了一个描述文件的东西。</p><p>先看有 Mac 时的签名验证，苹果保留原先苹果后台服务器上存一份私钥 A， 所有 iOS系统内置一个公钥 A 的模式。同时，Mac 上通过“钥匙串”生成 CSR 文件（就是在申请开发者证书时候需要提供过的那个文件）时，会生成一对公钥 B 和 私钥 B。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/IMG_0113.jpg" alt=""></p><ol><li>在开发者后台请求证书时， 会通过服务器的<code>私钥 A，对公钥 B 进行加密</code>。得到一个对应的证书。当安装到 Mac 上时，“钥匙串”会将 私钥 B 关联上这个证书。</li><li>当通过 Xcode 出包的时，通过 <code>私钥 B 对 App 进行签名</code>，同时将上一步得到的<code>证书放入 App 包里</code>。</li><li>当将 App 安装到 iPhone 时，通过 iOS 系统内置的私钥 A，<code>解密得到公钥 M</code>。</li><li>拿到公钥 M， 再去解密验证第二步中<code>通过 私钥 B 对 App 的签名</code>。</li></ol><p>然后是描述文件。苹果为了防止应用被随意安装和权限乱用，又引入的描述文件。</p><ul><li>只有在描述文件里配置过的设备才可以安装。</li><li>只有在描述文件内配置过的权限，才可以在工程中进行设置使用。</li></ul><h2 id="手动重签名">手动重签名</h2><h3 id="解压-App">解压 App</h3><p>直接使用类似的<code>The Unarchiver</code>这样工具直接解压即可。或者直接改成 .zip进行解压。解压后会得到一个<code>Payload </code>文件夹。</p><h3 id="查看-APP-的签名信息">查看 APP 的签名信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codesign -vv -d demo/Payload/shediao-lz-tw.app</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/1_%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF.png" alt=""></p><h3 id="删除插件文件夹">删除插件文件夹</h3><p>我这个包是不带插件的，但有时候会遇到带插件的包，普通的证书文件是不能对插件进行签名。所以这里先右键显示包内容，把里头的<code>Watch</code>和<code>PlugIns</code>那文件夹删掉。</p><h3 id="签名-Framework">签名 Framework</h3><p>首先得对所有的动态库 Framework 进行签名。在 <code>Framework</code>文件夹下，有所有需要签名的文件。签名的证书也可以使用命令行直接列出来。后面的名字，就是签名的时的参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出电脑上所有的证书</span></span><br><span class="line">security <span class="built_in">find</span>-identity -v -p codesigning</span><br><span class="line"><span class="comment">//签名FrameWork</span></span><br><span class="line">codesign -fs <span class="string">"（证书名称）"</span> xxxxx.FrameWork名称</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/3_%E7%AD%BE%E5%90%8D%E5%8A%A8%E6%80%81%E5%BA%93.png" alt=""></p><h3 id="给-MachO-文件添加可执行权限">给 MachO 文件添加可执行权限</h3><p>这个 MachO 文件就是 Mac 平台和 iOS 平台上的可执行文件的简称，在包里头有一个和 xxx.app 名字相同的文件。需要给他提供一个可执行权限。<code>chmod</code>一下就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如我这的例子是shediao-lz-tw</span></span><br><span class="line">chmod +x shediao-lz-tw</span><br></pre></td></tr></table></figure><h3 id="替换描述文件">替换描述文件</h3><p>通过前面的证书原理可以知道，签名还需要一个正确的描述文件。那么我们可以通过创建一个新的工程，用签名的证书在真机上运行一下就能得到一个描述文件，将这个描述文件放到需要重签名的包内容中即可。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/4_%E8%8E%B7%E5%8F%96%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6.png" alt=""></p><h3 id="替换-bundleId">替换 bundleId</h3><p>在包内容里，有一个 info.plist 的文件，需要修改里头的 BundleId 和上面生产描述文件的 BundleId 一样。</p><h3 id="创建-Property-List-文件">创建 Property List 文件</h3><p>在签名的时候还需要一个 plist 文件。<br>我么你可以通过 Xcode 新建一个<code>PropertyList</code>文件，里头的信息则是上一步生产的描述文件里头的部分内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过命令能查看描述文件的信息</span></span><br><span class="line">security cms -Di embedded.mobileprovision</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/05_%E5%8E%9F%E5%A7%8B%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF.png" alt=""></p><p>复制红框的中内容，黏贴到新的<code>PropertyList</code>文件里，然后保存一份到和 xxxx.app 文件同级的目录下。</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/7_%E6%9B%BF%E6%8D%A2%E4%BF%9D%E5%AD%98plist.png" alt=""></p><h3 id="签名-App-真机安装">签名 App &amp; 真机安装</h3><p>最后一步，执行命令 <code>codesign 命令</code>签名就大功告成了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  ~/Documents/<span class="number">12</span>_ipa_crack/demoApp/demo/Payload&gt; codesign -fs <span class="string">"z证书名称"</span> --no-strict --entitlements=demoApp.plist shediao-lz-tw.app   </span><br><span class="line"></span><br><span class="line"><span class="comment">//执行完成后，能显示下面这句提示，就可以直接用真机检测是否能成功安装了</span></span><br><span class="line"> shediao-lz-tw.app: replacing existing signature</span><br></pre></td></tr></table></figure><p>这里可以直接通过 Xcode 的设备窗口，<code>菜单栏 - Window - Device and Simtlators</code>（shift+command+2）</p><ul><li>[+]</li><li>选择签名好的 App 包</li><li>选择 replace<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/8_%E6%9B%BF%E6%8D%A2%E5%AE%89%E8%A3%85.png" alt=""></li></ul><p>需要调试的时候，在手机上启动应用，<code>菜单栏 - Debug - Attach to Process-选择对应的应用</code>。例如就可以调试不同按钮对应的函数。有了这些，hook 一些按钮就能更轻松的找到对应的类和函数了。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/9_%E8%B0%83%E8%AF%95%E7%95%8C%E9%9D%A2.png" alt=""></p><h2 id="脚本自动化重签名">脚本自动化重签名</h2><p>上面的是签名方式，全都是在敲命令行，作为程序员最优秀的品质 — ”懒“，让这套流程可以变成自动化的脚本就好。 就类似平时开发一个 App ，直接在 Xcode 上点 Run 就可以在真机上调试。这样的话，之后要用 动态库逆向也更加方便调试。</p><h3 id="目录准备">目录准备</h3><ol><li>需要新建一个 App工程</li><li>在工程的同级目录下创建一个 <code>APP</code>文件夹。取别的名字也行，和脚本里保持一致即可。<br>如下图三个红框圈出来的结构。另外两个文件夹，有一个是自动生成的临时文件，FXHook 是后期做动态注入的文件夹，暂时忽略。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/10_%E8%84%9A%E6%9C%AC%E5%B7%A5%E7%A8%8B.png" alt=""></li></ol><h3 id="脚本">脚本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># $&#123;SRCROOT&#125; 它是工程文件所在的目录</span><br><span class="line">TEMP_PATH=<span class="string">"$&#123;SRCROOT&#125;/Temp"</span></span><br><span class="line">#资源文件夹，我们提前在工程目录下新建一个APP文件夹，里面放ipa包</span><br><span class="line">ASSETS_PATH=<span class="string">"$&#123;SRCROOT&#125;/APP"</span></span><br><span class="line">#目标ipa包路径</span><br><span class="line">TARGET_IPA_PATH=<span class="string">"$&#123;ASSETS_PATH&#125;/*.ipa"</span></span><br><span class="line">#清空Temp文件夹</span><br><span class="line">rm -rf <span class="string">"$&#123;SRCROOT&#125;/Temp"</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">"$&#123;SRCROOT&#125;/Temp"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">1.</span> 解压IPA到Temp下</span><br><span class="line">unzip -oqq <span class="string">"$TARGET_IPA_PATH"</span> -d <span class="string">"$TEMP_PATH"</span></span><br><span class="line"># 拿到解压的临时的APP的路径</span><br><span class="line">TEMP_APP_PATH=$(<span class="built_in">set</span> -- <span class="string">"$TEMP_PATH/Payload/"</span>*.app;echo <span class="string">"$1"</span>)</span><br><span class="line"># echo <span class="string">"路径是:$TEMP_APP_PATH"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">2.</span> 将解压出来的.app拷贝进入工程下</span><br><span class="line"># BUILT_PRODUCTS_DIR 工程生成的APP包的路径</span><br><span class="line"># TARGET_NAME target名称</span><br><span class="line">TARGET_APP_PATH=<span class="string">"$BUILT_PRODUCTS_DIR/$TARGET_NAME.app"</span></span><br><span class="line">echo <span class="string">"app路径:$TARGET_APP_PATH"</span></span><br><span class="line"></span><br><span class="line">rm -rf <span class="string">"$TARGET_APP_PATH"</span></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">"$TARGET_APP_PATH"</span></span><br><span class="line">cp -rf <span class="string">"$TEMP_APP_PATH/"</span> <span class="string">"$TARGET_APP_PATH"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">3.</span> 删除extension和WatchAPP.个人证书没法签名Extention</span><br><span class="line">rm -rf <span class="string">"$TARGET_APP_PATH/PlugIns"</span></span><br><span class="line">rm -rf <span class="string">"$TARGET_APP_PATH/Watch"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">4.</span> 更新info.plist文件 CFBundleIdentifier</span><br><span class="line">#  设置:<span class="string">"Set : KEY Value"</span> <span class="string">"目标文件路径"</span></span><br><span class="line">/usr/libexec/PlistBuddy -c <span class="string">"Set :CFBundleIdentifier $PRODUCT_BUNDLE_IDENTIFIER"</span> <span class="string">"$TARGET_APP_PATH/Info.plist"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">5.</span> 给MachO文件上执行权限</span><br><span class="line"># 拿到MachO文件的路径WeChat</span><br><span class="line">APP_BINARY=`plutil -convert xml1 -o - $TARGET_APP_PATH/Info.plist|grep -A1 Exec|tail -n1|cut -f2 -d\&gt;|cut -f1 -d\&lt;`</span><br><span class="line">#上可执行权限</span><br><span class="line">chmod +x <span class="string">"$TARGET_APP_PATH/$APP_BINARY"</span></span><br><span class="line"></span><br><span class="line">#----------------------------------------</span><br><span class="line"># <span class="number">6.</span> 重签名第三方 FrameWorks</span><br><span class="line">TARGET_APP_FRAMEWORKS_PATH=<span class="string">"$TARGET_APP_PATH/Frameworks"</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"$TARGET_APP_FRAMEWORKS_PATH"</span> ];</span><br><span class="line">then</span><br><span class="line"><span class="keyword">for</span> FRAMEWORK in <span class="string">"$TARGET_APP_FRAMEWORKS_PATH/"</span>*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">#签名</span><br><span class="line">/usr/bin/codesign --force --sign <span class="string">"$EXPANDED_CODE_SIGN_IDENTITY"</span> <span class="string">"$FRAMEWORK"</span></span><br><span class="line">done</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#注入,这一行是注入用的，先注释，FXHook就是我自己创建的动态库名称</span><br><span class="line"><span class="meta">#yololib <span class="meta-string">"$TARGET_APP_PATH/$APP_BINARY"</span> <span class="meta-string">"Frameworks/FXHook.framework/FXHook"</span></span></span><br></pre></td></tr></table></figure><h3 id="工程设置">工程设置</h3><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/11_%E8%84%9A%E6%9C%AC%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AE.jpg" alt=""></p><h2 id="end">end</h2><p>这么设置好之后，直接和平时开发一样，连接手机，直接运行调试就好了。也就有了做动态库注入的基本环境。</p><p>填了 1/2 的坑，下一篇再聊聊剩下的动态注入的事。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 反编译 </category>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反编译旅行青蛙 For Android Unity</title>
      <link href="/2021/01/11/2021-01-11-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%97%85%E8%A1%8C%E9%9D%92%E8%9B%99%20For%20Android%20Unity/"/>
      <url>/2021/01/11/2021-01-11-%E5%8F%8D%E7%BC%96%E8%AF%91%E6%97%85%E8%A1%8C%E9%9D%92%E8%9B%99%20For%20Android%20Unity/</url>
      
        <content type="html"><![CDATA[<p>前阵子，无意中接触了一下反编译的内容。本来挺忙的，恰好又因为隔壁出现个新冠确诊，导致隔离。宅在家就把思路写一下呗。</p><p>ps：本文章只用作记录学习。绝无其他用途。</p><h2 id="工具">工具</h2><ul><li>dnSpy-反编译代码</li><li>Unity Studio -资源替换</li><li>Unity AssetBundle Extractor-资源替换</li><li>apktool-解包/打包/签名</li><li>Android逆向助手-签名(偷懒选手）</li></ul><p><code>这次测试的环境用的win7. 我本人没有 Windows 机器，是在 PD 上装的 Windows 虚拟机</code><br><a href="https://gitee.com/zzRong/tools/blob/master/unity%20%E5%8F%8D%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7.zip" target="_blank" rel="noopener">本文用到的unity反编译工具</a></p><h2 id="解包">解包</h2><p>Untiy 主要的代码会编译成一个 dll 文件，名称为<code>Assembly-CSharp.dll</code>。我们要做的就是反编译这个文件。那么第一步，是解压 apk 包。 有不少教程会说可以直接改成 zip，用自带工具解压。但经过我尝试之后，发现这样的确可以成功解包，但是这样解出来的包，再之后重新打回APK时，运行时是有问题的。因此，我更推荐使用 apktool 进行解包。</p><p>下载与安装方法官方地址都有给 :<a href="https://ibotpeaches.github.io/Apktool/install/" target="_blank" rel="noopener">Apktool - How to Install</a>。安装好之后，用命令解包就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d xxxxx包名字.apk</span><br></pre></td></tr></table></figure><p>解压完之后，<code>Assembly-CSharp.dll</code>的目录就在<code>解包后目录/assets/bin/Data/Managed/Assembly-CSharp.dll</code></p><h2 id="反编译代码">反编译代码</h2><p>解压完成只有，我们就可以使用 dnSpy 加载上述的<code>Assembly-CSharp.dll</code>。</p><p>在左侧边栏找到你需要修改的类，然后右侧可以查看源代码，找到对应的方法，右键，修改完成之后点编译，全部完成之后，选择文件-全部保存就 OK 了。对于这种没加密的源码，一气呵成，简直不要太简单。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%8F%8D%E7%BC%96%E8%AF%91dll%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81.png" alt=""></p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BF%9D%E5%AD%98.jpg" alt=""></p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%85%A8%E9%83%A8%E4%BF%9D%E5%AD%98.jpg" alt=""></p><h2 id="反编译资源">反编译资源</h2><p>代码反编译完成之后，一般还会有需要替换资源的需求。譬如要替换某图集里的某个小图资源。</p><p>首先是要找到这个资源所在的图集，然后替换这个图集内的你想要替换的纹理。<br>找图集可以用 Unity Studio 这个工具。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%8F%8D%E7%BC%96%E8%AF%91%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E5%9B%BE%E9%9B%86.jpg" alt=""><br>在 Asset List 页签下能看到所有的资源列表。这里可以用上面的筛选框进行关键字检索。<br>比如这里需要替换掉某个图标，就可以尝试直接去搜 icon。然后在对应的这个 item 上直接右键，选择  <code>show original file</code> ，就可以定位到对应的资源了。</p><p>那么下一步，就是替换这个资源内的小图纹理。可以使用  Unity Asset Bundle Extractor 打开该文件。<br>这里会发现一个图，包含了一个 Sprite 和一个 Texture。 做游戏的肯定都知道，我们要换的就是这个 Texture。选择 Plugins 替换掉对应的图片资源即可。<br>对应步骤如图：</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%8F%8D%E7%BC%96%E8%AF%91%E6%9B%BF%E6%8D%A2%E8%B5%84%E6%BA%90.png" alt=""></p><p>同样的方式，还可以替换 TextAsset 的配置文件。先导出到本地，然后用记事本等软件修改，完成后再用 import 替换回去就完成了、</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E6%9B%BF%E6%8D%A2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt=""></p><h2 id="重新打包签名">重新打包签名</h2><p>等全部修改完成，就可以直接修改打包了。 之前解包用的是 apktool。重新打包也是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b xxxxx文件夹</span><br></pre></td></tr></table></figure><p>当然，如果你为了可以能真机运行，我们还需要对应用进行签名，这里可以偷懒一下，我是在网上上搜一些工具，我这用的是 <code>Android 逆向助手</code>，直接把包扔进去操作就大功告成了。<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%8A%A9%E6%89%8B%E6%88%AA%E5%9B%BE.jpg" alt=""></p><h2 id="End">End</h2><p>这篇文章仅用作学习之用，记录一下对一些没有加密的 unity 工程的逆向过程。可以发现如果游戏不做加密措施，不做代码混淆，可以很简单的就被Crack掉。</p><p>这里是安卓的反编译，这种没加密的还是很简单的。 自己还研究了一下 iOS 的反编译。它的方式就和安卓这种方式完全不一样，采用的是动态库注入的方式。</p><p>先埋坑，之后有时间，再填上~~</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 反编译 </category>
          
          <category> unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用colyseus和cocos开发状态同步游戏</title>
      <link href="/2020/06/15/2020-06-15-%E4%BD%BF%E7%94%A8colyseus%E5%92%8Ccocos%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/06/15/2020-06-15-%E4%BD%BF%E7%94%A8colyseus%E5%92%8Ccocos%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81%E5%90%8C%E6%AD%A5%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="状态同步">状态同步</h2><p>顾名思义，状态同步就是让不同客户端的状态保持一致。而为了保持一致性，这个状态也可以是服务器计算的。比如，<code>客户端 A 以 8 的速度向前移动</code>这个状态，服务器需要算出每个客户端的位置，并且派发给其他客户端。而具体到客户端，只需要在收到服务端的推送功能更之后，更新各个显示对象的位置就好了。</p><h2 id="colysues">colysues</h2><p>为了实现状态同步，有很多库。比如这个 colyseus。<a href="https://colyseus.io/" target="_blank" rel="noopener">Colyseus - Multiplayer Game Server for Node.js</a>。</p><p>它实现了一些状态函数，且自动管理一个状态树。对于开发者，只要了解它主要的几个概念，比如<code>Client</code>, <code>Room</code>, <code>State</code>就能很快上手做一个小demo了。</p><p>概括一下：每个客户端自身都是一个 <code>Client</code>, 可以通过<code>joinOrCreate</code> 等方式加入到<code> Room</code>。 加入这个 <code>Room</code> 内的所有 <code>Client</code> 就可以理解成一条船上的人了。 当有 <code>Client</code> 的状态变化，Colyseus 都会通知给在 <code>Room</code> 内的其他 <code>Client</code>。</p><p>这样一来，我们做开发的就只要关心具体的游戏逻辑处理， 一个字 “爽！”</p><h2 id="服务端-Demo">服务端 Demo</h2><p>尝试写写 Demo，掌握这些基本概念会比较快。这里准备写一个控制自己简单的控制移动的 Demo，各个客户端的信息能同步给房间内其他玩家。</p><p>由于这篇文章说的是状态同步，主要计算工作都是服务器，先看一下服务器的代码。</p><p>参照文档说的：<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/colyseusServer.png" alt=""><br>通过文档指导的方式新建一个新工程。</p><p>工程内的 <code>index.ts</code> 文件可以看到会启动一个 server，同时注册一个 Room</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> server = http.createServer(app);</span><br><span class="line"><span class="keyword">const</span> gameServer = <span class="keyword">new</span> Server(&#123;</span><br><span class="line">  server,</span><br><span class="line">  express:app</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// register your room handlers</span></span><br><span class="line">gameServer.define(<span class="string">'game'</span>, GameRoom);</span><br></pre></td></tr></table></figure><p>这个 GameRoom 就是客户端会加入进来的房间。而主要的逻辑代码，自然也就是在这个 GameRomm。</p><h3 id="消息处理函数">消息处理函数</h3><p>对于服务端的 Room，有 <code>onCreat</code>， <code>onJoin</code>，<code>onLeave</code>, <code>onMessage</code>  等方法。</p><p>创建房间 <code>onCreat</code> 时可以初始化房间内需要的数据结构，设置好房间内事件响应，计时器等。<br>当然这些方法的实现可以很灵活， 比如 <code>onJoin</code> 可以通过 <code>onMessage</code> 加上一个我们自定的消息来代替。例如</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">type</span> == <span class="string">"add"</span>) &#123;</span><br><span class="line">      <span class="comment">//...客户端加入后的逻辑处理（用于替代onJoin)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务器通过 <code>onMessage</code> 接收客户端的消息，这些信息里就可以包含例如玩家当前当前的方向。比如可以用两个变量分别代表 X 轴上的方向，和 Y 轴上的方向。</p><p>为此，可以与客户端协定好一个类型参数，客户端只要用这个类型参数包装好当前的操作，以固定频率，给服务器发送过去即可。<br>例如：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">onCMD(client: Client, <span class="keyword">type</span>: <span class="built_in">string</span>, message: <span class="built_in">any</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> player: Player = <span class="keyword">this</span>.getEntityById(client.sessionId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">type</span> == <span class="string">"add"</span>) &#123;</span><br><span class="line">      <span class="comment">//...客户端加入后的逻辑处理（用于替代onJoin)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">type</span> == <span class="string">"input"</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (player) &#123;</span><br><span class="line">        player.dirX = message.x;</span><br><span class="line">        player.dirY = message.y;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        client.send(<span class="string">"err"</span>, <span class="string">"2"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下一个问题就是，计算出来一个客户端的位置信息后，怎么同步给所有客户端。</p><h3 id="Schema-的数据同步">Schema 的数据同步</h3><p>其实比较传统的方法可以通过服务器的广播的方式。<br>而更高阶的做法是用 Colyseus 提供的 <code>Schema</code> 数据结构。用它之后，可以不再需要关心何时派发数据。知道 mobx 的同学，应该就很熟悉这个模式了。<br>只要对应的 <code>Schema</code> 变化了，如果客户端监听了<code>this.room.onStateChange</code>就会自动通知到对应的客户端。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//client端代码</span></span><br><span class="line"> <span class="keyword">this</span>.room.onStateChange(<span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> state.players) &#123;</span><br><span class="line">        <span class="keyword">const</span> element = state.players[key];</span><br><span class="line">        <span class="keyword">this</span>.updatePlayer(key, element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>因此在服务端只需要维护一个所有客户端的Schema：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Player <span class="keyword">extends</span> Schema &#123;</span><br><span class="line">  <span class="meta">@type</span>(<span class="string">"number"</span>)</span><br><span class="line">  <span class="keyword">public</span> x: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@type</span>(<span class="string">"number"</span>)</span><br><span class="line">  <span class="keyword">public</span> y: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@nosync</span></span><br><span class="line">  <span class="keyword">public</span> dirX: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="meta">@nosync</span></span><br><span class="line">  <span class="keyword">public</span> dirY: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...其他属性等</span></span><br><span class="line"><span class="comment">//...其他属性等</span></span><br><span class="line"><span class="comment">//...其他属性等</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">id: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  update() &#123;</span><br><span class="line"><span class="comment">//计算位置代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> State <span class="keyword">extends</span> Schema &#123;</span><br><span class="line">  <span class="meta">@type</span>(&#123; map: Player &#125;)</span><br><span class="line">  <span class="keyword">public</span> players = <span class="keyword">new</span> MapSchema&lt;Player&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 Player 是单个玩家的数据，例如当前方向，当前 id， 当前的位置等。<br>有些信息如果不希望被同步到其他客户端的话，可以通过<br><code>@nosync</code>语法糖来设置。<br>这么设计之后，就只要在收到初始化房间后设置的定时器内执行每个 Player的 update 方法去计算位置即可。</p><h2 id="客户端-Demo">客户端 Demo</h2><p>有了上面的服务器代码。客户端也就是一个接受消息，展示对应的客户端，更新客户端位置，当客户端离开房间后，移除对应的现实对象。<br>这里也没啥好说的。</p><p>注意一下客户端的操作信息发送频率和服务器的定时器频率保持一致。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//向服务器发起开始游戏</span></span><br><span class="line">  sendStartGame() &#123;</span><br><span class="line">    <span class="keyword">this</span>.players = [];</span><br><span class="line">    <span class="comment">//加入游戏</span></span><br><span class="line">    <span class="keyword">this</span>.sendToRoom(<span class="string">"add"</span>, <span class="keyword">this</span>.room.sessionId);</span><br><span class="line">    <span class="comment">//以固定时间间隔上传用户输入</span></span><br><span class="line">    setInterval(<span class="keyword">this</span>.sendCMD.bind(<span class="keyword">this</span>), <span class="number">1000</span> / <span class="keyword">this</span>.serverFrameRate);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向服务器发送用户的操作指令</span></span><br><span class="line">  sendCMD() &#123;</span><br><span class="line">    <span class="keyword">let</span> dir = <span class="keyword">this</span>.mouseInput.toServerData().dir;</span><br><span class="line">    <span class="keyword">this</span>.sendToRoom(<span class="string">"input"</span>, dir);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>就写这些。完整的代码代码上传到 github 上了。<br><a href="https://github.com/stormrageLiu/my-colyseus-demo.git" target="_blank" rel="noopener"> my-colyseus-demo</a></p><p>demo截图：<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/20200708170530.png" alt=""></p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/20200708171748.png" alt=""></p><p>其实在实际开发中，不会单纯的使用状态同步，就比如这个状态同步，也会使用消息队列的形式先保存起需要做的操作，以保证更好的操作体验。而这正好和帧同步的思路是一样的。<br>之后有机会再写一下帧同步吧 <em>(给自己挖坑)</em>，帧同步和状态同步的区别正好反过来，主要计算是在客户端，还需要做追帧等操作。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 同步游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏集成苹果IAP内购</title>
      <link href="/2020/05/23/2020-05-23-%E6%B8%B8%E6%88%8F%E9%9B%86%E6%88%90%E8%8B%B9%E6%9E%9CIAP%E5%86%85%E8%B4%AD/"/>
      <url>/2020/05/23/2020-05-23-%E6%B8%B8%E6%88%8F%E9%9B%86%E6%88%90%E8%8B%B9%E6%9E%9CIAP%E5%86%85%E8%B4%AD/</url>
      
        <content type="html"><![CDATA[<h1>游戏集成苹果内购（IAP）</h1><p>做游戏的，肯定是绕不过去苹果这个平台的。而且苹果的审核是众所周知的坑，特别是对支付这一块。国内大多数玩法，是由 cp 提供游戏，然后找一家（或者 N 家）渠道去上不同的平台。</p><p>这种玩法的好处就是，做游戏的 cp 方，只需要对接好渠道的 sdk 就好了， 然后由渠道去推到不同的平台。至于不同平台上可能遇到的坑，渠道的 sdk 应该基本都完善过了。比如，苹果支付就是天然的坑，网上一搜一大堆相关的介绍，大致流程都一样。刚好自己这次需要接入这么个东西，记录一下。</p><h2 id="苹果的支付流程与丢单">苹果的支付流程与丢单</h2><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/20200605151225.png" alt=""></p><p>我自己画了个大概的图，整个支付流程是以客户端中心的。而我们知道的大多数支付系统，都是以服务器为中心，客户端只要发起支付，之后的流程就完全依赖于平台的服务器和游戏服务器之间的通信了。</p><p>这样的好处是更好的保证了交易的完整性，但是缺点也有，就是对个人开发者而言，维护成本更高，比如就想做个休闲小游戏的内购，都还要假设一台服务器。</p><p>而苹果的这套支付机制，更好的方便了个人开发者，但是对支付的完整性就存在很多问题，比如很多人诟病的丢单问题。</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/55849068-DB4D-4921-9DA4-DC291CB4B0FF.png" alt=""></p><p>上面两个图能看出， 如果先完成支付之后，之后的验证订单步骤因为其他原因失败了，就会出现丢单的情况。这也是苹果支付上经常出现的BUG：<code>丢单，用户付钱了，但是没收到货。不能忍啊</code></p><p>大多数情况都是因为网络波动导致的丢单。比如在第 5 步，当客户端收到来自苹果的支付收据应该向游戏服务器进行二次验证的时候，网刚好断了，游戏服务器没收到支付凭证，玩家也就收不到货了。</p><h2 id="本地化订单">本地化订单</h2><p>由于整个支付机制是以客户端为中心进行的。为了防止丢单，主流做法是将订单保存起来。在 iOS 上有很多本地保存的方法。我是用 <code>NSKeyedArchiver</code>来实现的。</p><p>可以维护一个遵守<code>&lt;NSCoding&gt;</code>协议的自定义对象 PayInfo ;</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IAPPayInfo</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>&gt; </span>&#123;</span><br><span class="line">   <span class="built_in">NSString</span> *_productid;</span><br><span class="line">    <span class="keyword">int</span> _count;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">    <span class="built_in">NSString</span> *_price;</span><br><span class="line">  <span class="built_in">NSString</span> * _uid;</span><br><span class="line">    <span class="built_in">NSString</span> * _receipt;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后维护一个 <code>NSDictionary</code>， 用<code>key - value</code>的形式进行存储，并进行归档处理。</p><p>流程上可以：</p><ul><li>当用户发起支付的时候，生成一个 payInfo，和一个订单 id （这一步可改进，后面再说）；</li><li>当收到苹果订单收据的时候，通过携带的订单 id 去更新对应的 payInfo 的收据；</li><li>当游戏服务器二次验证成功返回后（订单有效）从删除对应的 payInfo ；</li></ul><p>其实还有一个情况，当苹果订单支付返回失败时，理论上应删除对应的 payInfo。但是我不建议这么做！这里有一个坑点：<strong>当App Store的policy更新时</strong>，一笔成功的订单，会先收到一个<code>SKPaymentTransactionStateFailed</code>的失败回调，然后紧接着再收到<code>SKPaymentTransactionStatePurchased</code>成功回调。</p><p>同时为了防止正常失败的无效订单轮训的次数太多，可以通过增加 payInfo 的状态属性或者判断收据字段来排除过多的无效请求。轮训上也可以使用递增时间间隔来做优化。</p><h2 id="关于订单完结">关于订单完结</h2><p>苹果官方的文档关于这个接口又是这么写的：<br><a href="https://developer.apple.com/documentation/storekit/skpaymentqueue/1506003-finishtransaction?language=objc" target="_blank" rel="noopener">苹果接口文档 finishTransaction: </a><br>![]<img src="https://gitee.com/zzRong/MyPics/raw/master/img/57969E17-BE75-4232-9D25-2EB81972998B.png" alt=""></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">SKPaymentQueue</span> defaultQueue] finishTransaction:tran];</span><br></pre></td></tr></table></figure><p>苹果的做法是通过设置<code>SKPaymentTransactionObserver</code>delegate 来给客户端回调支付状态的。<br>如果客户端不finish这个订单，下次再登录的时候，还会继续通过delegate回调个客户端。</p><p>因此，其实正常情况下，是可以只依赖苹果系统的回调来做补单操作，等服务器二次验证之后再执行完结订单的操作。</p><p>苹果的文档中也提示：对于成功的订单需要在完结订单之前去验证这笔订单。不过对于失败的订单，是需要直接完结的。这一点其实在 13.4系统之前是没问题的，<strong>而自从更新了 13.4 系统之后，如果收到订单不立即执行finish操作，下一笔订单将会直接失败！！</strong> 用13.4系统自测可以复现：拉起支付- 取消支付- 再拉起支付，结果是之后的支付都直接提示失败。</p><p>然而，再对比上面一节说的<strong>当App Store的policy更新时会先收到一个失败回调再收到成功</strong>的情况。失败直接完结订单，就可能会导致丢单的情况。</p><p>所以，最后的方案还是一了百了。不再依赖苹果的回调作为补单，收到订单状态后直接完结订单，全部本地化保存订单的方式。</p><h2 id="用户系统映射">用户系统映射</h2><p>购买成功，服务器需要给用户发道具，那二次验证的时候客户端需要把对应的用户游戏内的 id 发送过去的。<br>而苹果在发起支付的时候，只提供了一个<code>payment.applicationUsername</code>属性用来传递参数。</p><p>也就是说，在发起支付的时候，客户端生成一个唯一 orderid 作为 payInfo 对象的key，将玩家 uid 保存在这个支付结构体内，然后设置<code>payment.applicationUsername </code>的值为<code>orderid</code>，在收到苹果回调的时候，用这个值去查询对应的 payInfo，这样整个支付相关的数据也就能取出来了。</p><p>不过这里也存在一个坑，当用户的 apple id 没有绑定过任何支付方式，首次发起购买时，会先跳转出去设置付款方式，等设置完再完成付款时，收到来自苹果的订单回调中的<code>payment.applicationUsername</code>会为 <code>nil</code>。</p><p>但这个<code>payment.applicationUsername </code>是苹果目前唯一允许携带个人信息的字段了。如果遇到这种返回<code>nil</code>的极端情况，可以通过 keyChain 和  transactionDate 的购买时间范围尝试恢复订单但是也不能 100% 匹配上。</p><h2 id="其他">其他</h2><p>苹果的支付流程，应该是先从 AppStore 请求支付商品，然后拿着商品信息再想 AppStore 发起支付。也就是本文第一个图的 第 1、2 两步。</p><p>而游戏内常见的做法是游戏内进行配表，在配表内将 AppStore 后台对应的商品 ID 填上，直接跳过苹果请求订单的步骤，利用配表内的信息去创建订单。</p><p>但是，创建支付订单<code>SKMutablePayment</code>之前可以直接通过ProductId直接创建，而现在，从苹果API上可以看出，发起支付的参数是不再允许使用</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">SKMutablePayment</span> paymentWithProductIdentifier:(<span class="built_in">NSString</span> *)identifier</span><br><span class="line"><span class="comment">//取而代之的是:</span></span><br><span class="line">[<span class="built_in">SKMutablePayment</span> paymentWithProduct: (<span class="built_in">SKProduct</span> *)product]</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/BD2BFBB1-52B8-484F-9546-C95D87069D6A.png" alt=""></p><p>但也不是没办法，只要设置上这个<code>SKMutablePayment</code><br>的<code>productIdentifier</code>属性也是一样的。可以直接通过原始的alloc来做：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SKMutablePayment</span> *payment = [[<span class="built_in">SKMutablePayment</span> alloc]init]; </span><br><span class="line">payment.productIdentifier =  <span class="string">"productId"</span>;</span><br></pre></td></tr></table></figure><p>不过我这里还是使用了<code>[SKMutablePayment paymentWithProduct: (SKProduct *)product]</code>这个方法来创建 payment。<br>不过换了一下做法，而是在游戏启动的时候，直接从 AppStore 上请求所有的支付数据，然后保存在一个 <code>NSMutableDictionary</code>中，然后当游戏内点击某商品准备购买的时候，再从这个<code>NSMutableDictionary</code>中取出对应的 <code>SKProduct</code>。</p><p>这样，当返回的 <code>SKProduct</code> 不为空的时候，直接用它创建订单，否则就使用<code>payment.productIdentifier =  &quot;productId&quot;;</code>的方式进行创建。</p><p>Ps  ：填坑完成呀</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 支付 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链和比特币</title>
      <link href="/2019/05/21/2019-05-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E6%AF%94%E7%89%B9%E5%B8%81/"/>
      <url>/2019/05/21/2019-05-21-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E6%AF%94%E7%89%B9%E5%B8%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文共计 4308 字，阅读时间大概 7 分钟。</p></blockquote><p>可能很多人都听说区块链，也听说过比特币。</p><p>这些词都非常耳熟，也能张嘴就来。但真对这几词有多少了解呢？</p><p>首先。这是一片很长的文章，如果要一言以蔽之的话，比特币是区块链的一个具体应用。</p><p>但这么说好像是句大白话，听了也白瞎。不妨就慢慢往后开。看完之后应该能了解到</p><blockquote><ol><li>所谓「去中心化」是什么</li><li>一个好玩的的非对称加密</li><li>挖比特币的矿工在做什么</li><li>为什么认为比特币有总量上限</li></ol></blockquote><h2 id="去中心化">去中心化</h2><p>去中心化，那肯定就有一个中心化的概念吧。</p><p>举个例子，我们家里应该都有路由器，有了它，就可以全家人的手机都用上 WiFi 了。由一个中心提供服务的模式，就是中心化。</p><p>但是这种中心化的模式存在问题啊，比如一家子中老爸掌管着路由器的管理员的账号，那老爸想限制掉儿子的网速就限制掉了。参与这个网络中的每个用户权利明显是不一样的嘛。虽然这个例子不太好，但是想想自己小时候被掐掉网线的感觉，是不是也不太好。</p><p>所以，中心化虽然有一个好处是方便管理，但是网易这个管理者滥用权利岂不是就完蛋了。于是，去中心化的概念就有了。</p><p>什么是去中心化呢？</p><p>再打个比方来说，大家都去网上下载过电影，当出现了迅雷等 bt 下载工具之后，原来从某台服务器上下载模式，变成了可以从每一个拥有这个资源的人那里去下载。</p><p>也就是每个人都成了一个可以提供资源的点，每一个人都可以成为中心，这个模式就可以理解成去中心化。</p><p>在用这个思路去看看我们的当前的货币体系，我们花的每一笔钱，最后都是由我们的中央银行控制的。想让我们钱的贬值，只要增发货币就好了。当然，国家有自己的监管机构，当然不会这么干。但是这也是一种中心化的体系。</p><p>而比特币就正好相反。<strong>它一个通过区块链技术实现的去中心化的货币系统</strong>。</p><h2 id="去中心化账本">去中心化账本</h2><p>好，现在知道了什么叫去中心化，也知道了有一个去中心化的应用叫比特币。</p><p>竟然是称之为币，那就一定有记账吧。不然怎么知道每个人有多少币呢？或者怎么知道这个货币如何发型呢？于是这就有了「账本」的概念，而且还是一个**「去中心化账本」**。</p><p>账本，就是记账，把所有账目记录在一个地方，然后存起来。那去中心化账本呢？根据前面去中心化的说法，就是任何人手上都有一个存储了所有账目的账本。</p><p>比如说，「张三支付 1 个比特币给李四」这条记录不仅张三和李四的账本上有，连赵六的账本上也会有。</p><p>但是这样是有问题的，毕竟这个系统不是几个人之间使用的，而是面向全球都开放的。而且无法面对面核对，那</p><p><em>a. 如何保证记录的信息在网络传输中是完整的呢?</em></p><p><em>b. 如果保证记录的在网络传输中是没被篡改过，是可靠的呢？</em></p><p>我们都知道电脑存储信息的方式本质都是二进制，也就是只需要用 0 和 1 两个字符就可以表示出任何东西。比如我们的十进制的 2019 用二进制可以表示成 11111100011。而二进制实在是太长了，又可以把这一串0 、1 组合转换成十六进制。比如刚刚这一串就变成了 7e。</p><p>当然这些怎么来的不影响你往下看，只要知道一个道理，<strong>在计算机内部，信息都会被编码转换成 0 和 1 两个数字的组合。然后可以对其进行各类计算</strong></p><p>有了个这个理论基础，那么我们的所有记账信息，就可以变成数字了。而有了数字，就可以做很多逆天的操作了。</p><p>比如在 1993 年，美国提出了一种加密算法，这种算法可以将任意信息转换成长度不变，只能由原始信息，本文称为「明文」计算出「密文」，但不能由「密文」反向推导出「明文」。这个算法名称叫SHA算法，如今比特币使用的就是SHA第二代。也就是SHA-256。</p><p>我们可以在网上搜一个在线转换的网站试试看。比如我截图的这个</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/sha256.png" alt=""></p><p>那这么一来，只要在传输过程中，把明文和密文都发送过去。<strong>接收到的人只要将「明文」通过同样的 SHA 算法计算出「密文 B」，拿它跟收到的「密文 A」进行比对。如果一样，信息就可以确定是完整的了。</strong></p><p>那解决了信息的完整性之后，还有一个可靠性怎么办？比如说在传输过程中，被黑客劫持了信息。然后直接把原文信息给改了。然后把更改过的信息再经过加密发给你。信息虽然还是完整的了，但是内容都是假的。这可怎么办？</p><p>当然，这也难不倒牛逼哄哄的数学大佬。又出现了一中心的加密手段叫<strong>非对称加密</strong>。</p><p>不如做个小游戏，你在心里想任何一个三位数 N 并记下来。然后你把这个数乘以 11，得到结果 M， 然后再用 M 乘以 91得到最后的结果。</p><blockquote><p>M = 心里想的数 N  * 11</p><p>结果  = M * 91</p><p>取结果后三位 == N ？</p></blockquote><p>然后你看一下最后结果的后三位，是不是就是你刚刚想的那个数一样？</p><p>是不是很神奇？这个过程其实就做了一次非对称加密。非对称加密，就包含了一个<strong>公钥</strong>，可以理解成所有人都可以知道的公共钥匙。同时还包含了一个<strong>私钥</strong>，顾名思义就是私人所有的钥匙。</p><p>而在刚刚那个小游戏里头，我心里想的数是 521，可以理解成原始信息，也就是「明文」，通过私钥 91 算出来的结果是 47411。可以理解成密文</p><blockquote><p>M = 521 * 91 = 47411</p></blockquote><p>如果我把这个密文跟所有人说，只要把这个数乘以公钥 11 ，然后取后三位，就可以得到我想的那个数了。</p><blockquote><p>47411 * 11 = 521521</p></blockquote><p>而在比特币中应用的也是这个原理，只不过算法没那么简单，而是一个叫做 ECC 算法。</p><p>再综合起前面上一部分保持数据完整性的方法来看。就可以总结一下步骤了。</p><ol><li>通过 SHA-256 将 「明文」加密成「密文 A」。</li><li>然后随机生成一个私钥，通过 ECC 算法将「密文 A」用私钥进行加密得到「密文B」。</li><li>通过私钥生成公钥</li><li>将密文B 、 公钥、明文一起发送给其他用户。</li></ol><p>那其他用户<strong>只要用公钥解密得到密文A， 再讲原文通过同样的 SHA-256 算法得到新的密文C，再比对两者是否一致</strong>。</p><p>你看，接受的人只要拥有 明文，密文 和 公钥这三样东西，就可以检查出信息是否完整，同时验证是否信息被修改过。</p><p>**但是前提是私钥不能丢！**就跟你你家要是丢了。再好的防盗门也是不好使的嘛。</p><p>说了这么多了，还只是在说这个「去中心化账本」怎么保证传输安全的。似乎和比特币并没有什么关系啊。</p><p>别急，这些是为了给说比特币打的基础。</p><h2 id="比特币到底是啥">比特币到底是啥</h2><p>前面说了要记录一笔账就需要这么些信息来传输。但解决了传输安全的问题，还要<strong>面临一个如何保证所有人的账本数据同步问题。而也真是因为为了解决这个问题，区块链技术就大放异彩了</strong></p><p>数据同步，在中心化的体系中，可以以一台服务器上为准即可。但是去中心化，到底应该以水为准呢？</p><p>简单来说，第一步就是<strong>无脑的物理隔离</strong>。中本聪的思路是让所有用户都只认可一个唯一的账本。<strong>所有用户要往这个账本写入信息的时候，需要经过一些列非常繁琐的过程</strong>，而这个过程，就是后面要说的比特币产生的重要一步。</p><p>而当用户每完成一次繁琐的过程时，就会把信息接入到这个账本中，而完成的这个人，就拥有了这个数据块。</p><p>那怎么算完成这个过程的呢？不妨来看看这个账本是如何组成的。它由一个一个的信息块组成，每个块都记录着前一个块的加密等信息、固定信息、交易记录和<strong>一个随机数</strong>。</p><p>注意了，这个随机数，就非常非常的好玩了。也就是说这个数是可以不断的随机算出来的。然是规则是什么。前面说了，比特币采用的加密方式是用 SHA-256进行加密，而这个后缀256的含义就是用256个二进制的数表示出原始信息。<strong>而设计者中本聪还规定了，每个信息块的SHA-256之后的密文前 72 位必须是 0。</strong></p><p>这么一来，你们可以算算它的概率是多少了。</p><p>每一位只有 2 个可能，的要么是 0， 要么是 1。也就是概率是  2 的 72 次幂之 1。</p><p>这个数，用计算器按一按，大概是4.72 万亿亿分之一的概率。平均做4.72 万亿亿次 SHA-256 计算后，有可能可以得到一个数。</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E6%AF%94%E7%89%B9%E5%B8%81%E8%AE%A1%E7%AE%97%E6%AC%A1%E6%95%B0.png" alt=""></p><p>如果你要说用电脑很快就可以算出来的。那你就真的多了。就用我们普通的家用电脑来算，一秒大概能60-100万次的计算，这个4.72万亿亿的计算量，普通人电脑就怒要想着去算了。再去搜搜四川的深山里那么多的「矿场」的图，更能直接的感受到需要多么庞大的运算能力。</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E7%9F%BF%E5%9C%BA.jpeg" alt=""></p><p>但这么难为啥还有人会去计算呢？因为有奖励啊。比特币系统规定了，只要没增加一个区块，就可以得到一部分的比特币奖励。而具体多少，看当时的区块数量而定。</p><p>说到这里，应该就是明白了。<strong>挖矿，就是不断的算SHA-256的值，只要凑到了这个数，就可以创建一个区块，也就有了记账权</strong>。我们在某个市场进行比特币交易，这些信息就是由这些挖矿的替我们记录了。而他们的奖励，就是比特币，还有交易手续费。</p><p>交易手续费，我相信在任何交易中都会存在，但是在比特币这个系统中，还特别有意思。比特币系统的每一个块是有大小限制的，如果某一个记录正好放不下了，而这个旷工又这一刻又只有这一个区块的记账权，这时候，必然就会有一条交易信息被放弃。</p><p>由于新增一个信息块的难度如此之大，那么对于那种恶意不断地刷小额订单的交易信息就非常容易造成信息堵塞，这一点，做过运维的人应该最了解啦。所以手续费在一定程度上也防止了恶意拥堵的情况。要知道，比特币的最小单位可不是 1 个，就跟股市的最小单位也不是 1 股一样。<strong>比特币的最小单位是 10^(-8) 个比特币，一般称为 「一聪」</strong>。</p><p>那还有最后一个问题了，听说过比特币的人也许还听过，比特币的总量是不变的，而且每相隔 4 年会减半一次。</p><p>这个总量其实是认为计算出来的，而 4 年减半则是设计如此。</p><p>中本聪设计为每增加 21 万个区块，比特币的奖励就会减少一般。而第一个区块的初始奖励是 50 比特币，是由它自己创建的。按照全球的计算速度来算。大约是每 10 分钟可以产生一个区块。21 万个大约就需要</p><blockquote><p>210000 * 10 / 60 / 24 / 365 = 3.995 (年)</p></blockquote><p>也就有了每 4 年减半一次的说法。</p><p>而最小单位是一聪，也就是10^(-8) 个比特币。人们通过这个就可以计算出总量大概是 21 万个。但实际上，当挖矿的奖励变成如此至少的时候，还会有人参与挖矿么？这可能是个经济学问题了，比如会牵扯到交易手续费会不会增加呢。这些就不做讨论了。</p><p>好长好长的一篇文章，就这些吧，共同学习，共同进步呗。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 名词扫盲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑洞才不是洞</title>
      <link href="/2019/05/13/2019-05-13-%E9%BB%91%E6%B4%9E/"/>
      <url>/2019/05/13/2019-05-13-%E9%BB%91%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文共计约 2357 字，阅读时间大概 4 分钟。</p></blockquote><p>上一周，在路上随手读了读霍金老爷爷的一篇演讲稿，也随手就感慨了一下科学是如此的迷人。</p><p>在回来之后，带着这种好奇，又去读了些霍金的其他文章，为啥我没有去读诸如 《时间简史》 之类的呢。说的好听一点是先宏观的了解了解霍金他主要的研究，而他的公开演讲，肯定是比书要浅显易懂的。</p><p>而说的直白一点的话，就是三字：<strong>看不懂</strong>。哈哈哈哈哈~</p><p>有点废话了。写这篇的原因，纯粹就是因为黑洞这个词好玩。而且到处都能看到、听到这个词。但是问起来它到底是什么时，却很难说的清楚。不妨就借着热乎劲组织一下语言写出来，科普一下自己的脑子总是好的嘛。也许哪天用得上呢。</p><h2 id="黑洞才不是洞">黑洞才不是洞</h2><p>说到黑洞，太多太多的科幻电影里描述过这个词了。电影里更喜欢用虫洞来描述。反正听起来都很科幻的样子。</p><p>在电影里面，通过虫洞就可以通往另一个超级远的地方，比如某某某外星舰队，从超级远的银河系外就能跃迁到地球上，等等类似这样的描写。</p><p>记得当我第一次接触这个词的时候，还认为黑洞就是一个洞，都说了是洞了，就是一窟窿眼吧。从这头掉进去，从另一头出来。</p><p>当然，这肯定是错的了，不妨拿出一张纸，像这图里一样在两端各画一个点，A 点到 B 点很远，那从 A 点开始怎么能快速的到 B 点呢？</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/A-B.png" alt=""></p><p>其实只需要把这张纸对折一下，A、 B 两点是不是就重合了。<strong>那么 A 、B 两点通过折叠 2 维平面之后，就可以抄近路了</strong></p><p>而电影中的黑洞，也具备这个抄近路的特点，把它画在纸上是一个 2 维平面上圆，但是在实际的 3 维空间中，圆就变成了球。</p><p>以前每次看到电影出现的跃迁，奇点跳跃这些词除了高大上也不知道有啥意思，现在想想这个解释再看就好多了。毕竟这个解释很简单、很形象的科普了高维空间是怎么穿越低维空间这件事。</p><p>再回过头看看当时认为它是个平面的想法，还挺逗的。像井盖么？哈….</p><h2 id="飞不过去的洞">飞不过去的洞</h2><p>但这种方式真的能实现么？</p><p>穿越空间多么美好啊，一瞬间就可以跨越星系进行旅行。可是，科幻毕竟是科幻，这篇文章也不是来开脑洞的，而是就从霍金目前对黑洞的理论来聊聊黑洞–电影中的穿越黑洞，恐怕是行不通的。</p><p>为啥行不通呢？先回忆回忆有没有过这样的一个场景：</p><p>我们过年都放过烟花，或者平时向上扔过石头什么的。最后的结果都会落回地面。小学生应该都知道这是因为地心引力的原因。</p><p>可如果这个速度足够大呢？比如到了 11.2km/s ，这个就是第二宇宙速度，也叫逃逸速度，这时候，这个物体就会一直往上飞，最后能逃脱地球的引力束缚。但是逃脱不了太阳的舒服。而当速度继续增大，到42.2km/s 时， 也就是第三宇宙速度，它还能逃脱我们的太阳系的引力束缚。</p><p>这些速度看起来已经很大了吧？但是这些和光速(一般取300000km/s)一比，就显得很小很小了。</p><p>顺着这个思路，在 1783 年的时候，有人提出了有没有一个星球的引力足够大，大到它的逃逸速度需要比光速还要大。当光经过这个星球的时候，都会被这个星球的引力拉扯回去。</p><p>也就是说，光也无法逃脱这个星球的束缚。</p><p>我们都知道我们能看到物体是因为光会能在介质中传播，当光出不来的时候，自然也就看不到它了。但看不见并不代表那个不存在啊，通过别的方式有检查到这个区域的确是有引力存在的。</p><p>说到这，又和我们已知的光速在同一介质里传播速度不变的就冲突了。为啥引力还使得光速变慢，甚至传播不出去了呢？</p><p>这个问题是被爱因斯坦提出了一个广义相对论所解释的。他提出的<strong>空间是不平坦的，会被当中的物质和能量所弯曲</strong>。这个也被科学家通过观察太阳附近的无线电波的弯曲所证实了。</p><p>所以引力是可以弯曲周围的空间的，太阳的体积比较大，周围的空间也就大，所以周围的空间弯曲的程度就比较小。这个道理和你站在足球场上感受不到地球是圆的一样。</p><p>那如果有一个质量比太阳大的星球，也就是引力大的星球，而其体积又比太阳小的多，那这个星球周围的空间的弯曲程度就会特别大了。有点类似前面的折纸实验一样，那条折横就是那个质量极大，体积极小的星球。</p><p>一定有的！我们知道星球的自身引力是一个由外向内的力。比如太阳自身就有引力，而太阳内部又有大量的核聚变反应，大量的能量释放会产生一个由内向外的压力。这样两个力正好可以抵消。</p><p>但，某个恒星能量总会有烧完的一天，由内向外的这个力越来越小。星球就会逐渐被压缩，此时，也许会发生爆炸，如果爆炸之后的质量也许能够正好平衡掉当时的引力，它们会变成白矮星，或者中子星。’</p><p>要是足够大，引力自然也就足够大，它就会继续收缩，收缩足够小，空间弯曲程度就足够大。同时这个区域内的引力也足够大，到当光经过的时候也就逃逸不过去了。这，就是形成了黑洞。</p><p>当然了， 如果质量无穷大，体积无穷小，它还可以称之为<strong>奇点</strong></p><h2 id="end">end</h2><p>这么看，大概知道我们现如今，肯定是无法通过黑洞来进行时空旅行了。如果我们真的跳进去一个黑洞里，理论上是会引力被撕的粉碎的。</p><p>在霍金的理论中，还提到了粒子可以落入黑洞中，然后从黑洞中蒸发，并从当前的宇宙进入到了另一个宇宙。这一点不免让我想到了薛定谔的猫，只有你落入黑洞的时候你才知道结果，但是当你真的落入了黑洞的时候，你就再也无法知道了。也许落入的身体会变成某种粒子而跑到另一个宇宙中去，但是跳进去的人肯定不会知道了。</p><p>就这写吧，现如今的科学水平还做不到穿越黑洞，但是现在如今的科幻作家，导演们可以做到了。也许他们只是在憧憬未来永远也实现不了的场景，也许科幻中的情节在若干年后也会成为现实，比如 1968年的电影《太空漫游 2001》，就在画面中出现了手机。</p><p>所以，未来，谁知道呢。敢肯定的是，那个时候，你我肯定是不知道了。了解了解就好了嘛。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 名词扫盲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 名词概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指数基金 ETF</title>
      <link href="/2019/02/26/2019-02-26-%E6%B6%A8%E5%81%9C%E6%97%B6%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81--ETF%E6%89%AB%E7%9B%B2/"/>
      <url>/2019/02/26/2019-02-26-%E6%B6%A8%E5%81%9C%E6%97%B6%E7%9A%84%E4%B8%80%E8%82%A1%E6%B8%85%E6%B5%81--ETF%E6%89%AB%E7%9B%B2/</url>
      
        <content type="html"><![CDATA[<p>今天上证指数涨幅 5.6%，深证指数，创业板指数涨幅也都突破 5.5%。市场貌似被核弹点燃了一般。身边谈论的股市的人也逐渐多了。有朋友问我今天有没有赚大钱。很抱歉，我并没有。我说我一个上班族，哪有这么多时间去看个股。也就玩玩ETF。</p><h2 id="什么是指数">什么是指数?</h2><p>这篇文章一开始就说了好多 xxx 指数。其实指数这个词是统计学上的概念。维基百科上的解释是「对多种数据取样进行综合、叠加、统计等操作所获得的数值，具有特定意涵」。</p><p>稍微了解一点股票的人应该都知道各种指数。比如说到过的上证指数，它选取的是所有在上海证券交易所挂牌上市的股票作为样本，而它的特定涵义就是反映上海交易所挂牌股票总体走势。</p><p>如果感兴趣可以看一下这个计算公式。</p><blockquote><p>本日股价指数＝本日股票市价总值÷基期股票市价总值×100。</p></blockquote><p>同样的道理，我们就可以知道深证指数的样本就是所有在深圳证券交易所挂牌上市的股票。</p><p>这里顺道科普一下，中国目前有四家证交所。中国大陆目前只有两家证券交易所。一家上海证交所。另一家是深圳证交所。另外中国香港有一家香港证券交易所，中国台湾有一家台湾证券交易所。</p><p>回到正题上，从上面说的上证指数、深证指数来看，知道了指数选取的样本不同，指数的含义也不同。当然，指数的名称也自然不一样。</p><p>如果我们选取上海证交所上市的、规模大、流动性好、最具代表性的 50 只股票组成样本股。这样就可以得到另一个指数。也就是我们常说的上证50 指数。</p><p>再比如从上海和深圳证券市场中选取 300 支 A 股作为样本。这就得到了大名鼎鼎的沪深300 指数。</p><p>所以指数在市场里头依旧是一个统计学的概念。它不单单是由一只股票的价格决定，而是由很多支股票共同计算出一个数值。而所代表的含义也是由它的样本决定的。比如沪深300中，它的样本覆盖了沪深市场六成左右的市值，那么这个指数就具有良好的市场代表性。</p><p>再来回答指数是什么。指数就是跟踪了一篮子股票的按照特定公式计算出来的一个数值。</p><p>如果这一篮子股票都在跌。这个指数就会降低。反过来说，如果指数在上涨，那么这一篮子的股票整体就是上涨的。</p><p>也因为这样，所以我们可以听到有人说今天大盘涨的这么好，我还亏出了翔。这就是因为指数代表了整体的上涨，但你持有的那只股票不一定上涨啊。</p><p>那就有人问了，对于选股能力，炒股水平很一般的人来说，有没有一种东西能去买指数的？反正他代表的是一篮子股票。比如买上证50 这样规模名列前茅的 50 支股票，岂不是安全稳妥美滋滋。</p><p>答案是有的，那就是 ETF。</p><p>听起来是不是和基金很像。但是 ETF 和我们平时认知里头的基金是不是一样呢？先继续往下看。</p><h2 id="什么是ETF">什么是ETF?</h2><p>它是「ExchangeTradedFunds」的简写。直接翻译过来是交易所交易型基金。看完这个解释，应该和我当初一样，看着还是一头雾水。</p><p>翻译的通俗一点。它就是跟踪指数的基金。比如跟踪上证50 指数的 ETF 有华夏上证50ETF (510050)。那具体怎么跟踪这个指数涨跌的呢。其实很简单，就是按照上证50 的样本股的比例。比如我有 500 块钱，而上证50 指数有 50 个样本。只要按照规定的每个样本计算比例，将 500 块全部买完。这样指数的涨跌幅度就基本和ETF净值涨跌幅度一样了。</p><h4 id="ETF和基金、股票有什么区别？">ETF和基金、股票有什么区别？</h4><p>前面说了，这种买一篮子股票的做法看起来和我们所知道的基金很相似。但其实他们是有区别的。</p><p>首先普通的开放式基金是不能再场内交易的。而 ETF 是交易型开放式基金。也就是 EFT 可以在场内进行交易。</p><p>其次，开放式基金当天买入后，当天以及下一个工作日不能卖出。也就是 T+2 才可以卖出。而对于 ETF，只有当天是不能卖出，下一个工作日就可以卖出。也就是 T+1 可卖出。</p><p>这意味着，只要我们开一个账户，只要开盘后，我们就可以随时买入，T+1 后也可以随时卖出。这个交易模式和交易股票的方式就是一样的了。</p><p>虽然操作模式上和股票基本一样，但和股票对比的话。还是有区别的。这个区别也是很好的实惠：交易 ETF 不需要交印花税。</p><h2 id="最后">最后</h2><p>说的这些看起来 ETF 好像特别好。其实任何品种没有好不好之说。ETF 由于它自身的构成，导致了它的走势会更加平滑。比如最近这半个月，市场热度非常火热，尤其是几天，300 多股涨停。但是 ETF 并没有这样大的涨幅。你说这是好还是不好呢。</p><p>我看来，对于喜好风险、追求刺激、选股能力好、交易水平比较高的人来说，ETF 一点也不好。因为它看起来太稳，看起来赚不了大收益。</p><p>但是对于一个不以炒股为主业，希望保持稳定一点的现金流，市场投资只是一种理财方式的人来说，ETF 又显得非常好。因为它给足了时间让我操作，有可能一波行情上涨了 10%。但是反映到指数，再反映到 ETF 上，可能就是分成了每天 3% 左右的样子慢慢上涨。给了我更多的时间去判断和决策。</p><p>再说说的对 ETF 的看法。</p><p>在我看来 ETF 是一个比较稳健，也相对自由的市场工具。每个人有每个人的用法，找一个自己喜欢的方式。适当的做好资产规划，尽可能保证熊市不亏，牛市跟上。至于赚多少，交给市场就好了。而 ETF 能够很好代表着市场。</p><p>就这样开开心心的把钱赚了不也挺好。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 名词扫盲 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 理财 </tag>
            
            <tag> 名词概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>价格由什么决定</title>
      <link href="/2019/02/18/2019-02-18-%E4%BB%B7%E6%A0%BC%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A/"/>
      <url>/2019/02/18/2019-02-18-%E4%BB%B7%E6%A0%BC%E7%94%B1%E4%BB%80%E4%B9%88%E5%86%B3%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<p>身处帝都，对房价真是望而却步。每次和家里人聊起来北京的房价，他们都觉得不可思议。特别是我奶奶那一辈的人，一定会说上一句「北京的地怎么要这么贵啊？」他们更多的认为，房价贵是因为政府卖的地贵。</p><p>那房价的高低是由于高价的土地造成的么？或者换一个问法，商品到底是如何定价的？</p><p>要回答这个问题的，就需要先了解两个理论：<strong>「成本决定论」和「供需决定论」</strong></p><h2 id="成本决定论">成本决定论</h2><p>就比如我奶奶认为的，因为政府把这块地卖得很贵，所以开发商就得花更多的钱买这块地，他们要挣钱，就得用更贵的价格来卖掉在上面的建造的房子。</p><p>因为地贵，所以房价就贵。这里面的逻辑就是因为有成本，所以价格是由成本就决定的。这就是成本决定论的内容。这个观点认为产品的定价取决于产品的所有原材料成本。</p><p>任何一个行业都有一个合适的利润率。比如 20%，15% 等。忽略各类税等其他费用的话，按照成本决定论来说，房产公司的<strong>利润 = 成本 * 利润率（常量）</strong>。</p><p>按照这个简化版利润的计算公式来看，房产老板想要多挣钱，提高成本就成了唯一的选择。「提高成本竟然能使得公司盈利变多」？</p><p>那是不是提高 10 倍的价格拍下这块地，就会让房子也贵上 10 倍呢？如果是的话，那政府疯狂抬高地价，GDP 不就一直往上涨了。我们都知道这显然是不可能的。这么听起来就觉得很荒谬了。</p><p>所以<strong>成本决定论很显然是错误的观点。</strong></p><h2 id="供需决定论">供需决定论</h2><p>与成本决定论之对应的就是供需决定论。字面意思就能看出，定价是由供需关系决定的。</p><p>用供需关系来看房价为什么高？首先是因为人们对房子有大量的需求，从而导致了房价更高。然后又因为房价很高，便导致了土地的价格也随之变高。</p><p>这个逻辑和成本决定论就正好相反。</p><p>关于房子的例子可能大家都能理解。毕竟也只有我奶奶那个年代的人还保留着这个观念嘛。可是就算我们知道了这个道理，在生活中还是不免会犯这种错。</p><p>我们去国贸这样北京最繁华的地段吃一碗面，比去西五环外的小店里吃一碗面价格要贵很多。这时候，如果你去问老板怎么这么贵的话，老板一定会告诉你说：「我们这边店面租金贵啊，一天都挣不够门店的租金」。</p><p>老板说的的确是事实，但是如果你也这么相信了，就又掉进了成本决定论的误区。因为老板所说的内在逻辑已经错了。</p><p>正确逻辑应该是这样的：因为国贸这个地方有着大量的工作机会和资源，就有很多人都想留在这个地方，从而导致了其各种生成资料的成本就升高了，比如房租升高，比如人力成本的增高。同样又因为很多人想留在这个地方，三餐的吃饭需求就很高，吃饭需求的提高就再次提升了餐饮类价格。</p><p>最终的逻辑依旧是<strong>供需决定价格</strong>。也就是：<strong>不是产品的原材料决定了最终的售价，而是产品在市场上的供求关系决定了产品的最终价格。而当前产品的价格再次又反过来决定其原材料的价格。</strong></p><p>资本家都是贪婪的，他们会尽可能的赚更多的钱。然后用赚到的钱去反哺生产成本。如果赚到的钱能够抵消生产成本，就能够留住这些资源继续盈利。如果不能够留住这些资源，也就意味着缺乏盈利模式，即将走向失败。</p><p>前面说了是因为人们对房子有需求，才导致了房价变贵。这里就可以假设一个更极端的情况：如果现在北京只有一套房子能出售了，这套房子的价格会是多少？</p><p>因为只有一套房子了，但是大家都想拥有这套房子。有人出 500W，还有人出 600W，最后的售价一定是出价中最高的那个。只要有需求就会有价格，就算房子是免费送的，依然不会真的免费，只不过这个价格不在明面上体现出来，而是会出现各类的暗箱操作，最后得到房子的价格。除非这个房子没有任何人想要，这时候的价格才为 0 。所以<strong>供求关系决定价格，和成本没有任何关系。</strong></p><p>一个修自行车的师傅，一开始他也只能路边摆摊挣点小钱维持生计。后来共享单车的风口来了，几家公司重金任用。同样的手艺，在不同需求面前价格也就不一样了。</p><p>通过上面的叙述，知道了一个产品的售价肯定不单单是通过计算所有成本的得来的。一定会通过调研市场的供求关系得出一个适当的价格，然后再投放到市场上，根据供需关系再逐步进行调整。</p><p>这个供需决定论放到我们工作生活中来说，我们的价值并不是因为你在工作上加了多少班决定的，也不是因为多努力决定的。</p><p>当然，努力是必须的，但努力的方向也应该正确，因为我们的价值是由自身的供求关系决定。很多人都说核心竞争力这个词，其实说的也就是供需决定价格。决定你价值的是你能不能成为一个对他人，对团队有用的的人，如果缺你不可的时候，个人价值也自然就高了。至于薪资，那是迟早的事。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 供需关系 </tag>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>稀缺性的几点想法</title>
      <link href="/2019/01/24/2019-01-24-%E7%A8%80%E7%BC%BA%E6%80%A7%E7%9A%84%E5%87%A0%E7%82%B9%E6%83%B3%E6%B3%95/"/>
      <url>/2019/01/24/2019-01-24-%E7%A8%80%E7%BC%BA%E6%80%A7%E7%9A%84%E5%87%A0%E7%82%B9%E6%83%B3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>刚开完年会。而每到公司办年会的时候，有的人中了奖，有的人不中奖。没中的总会感慨一下，今年奖品要是多一点，自己运气再好点就好了。由于抽奖都从最小的奖项开始抽，因此中了小奖品的人还会惋惜道：「这个还不如不要，拿了五等奖就没有机会抽大奖了」。</p><p>这个很简单的情景里头，其实暗含了2个含义。一个是之前提到过的机会成本，不过这是被迫为了五等奖放弃了大奖而已。还有一个就是<strong>稀缺性</strong>。</p><p>古典经济学里头经常假设人是理性的，理性人是会考虑边际量的。但这个假设有可能也不成立。所以后来的行为经济学做了一系列的论证，它的出发点就是人不一定是理性的。</p><p>因此，不管假设人是不是理性的，都太过片面。但是上面提到的稀缺性，却是经济学的根基。因为稀缺性并不是人为假设出来的，而是实际存在的事实。那么为什么稀缺性就成了实际存在的事实，而非假设呢？</p><h2 id="什么是稀缺性">什么是稀缺性</h2><p>稀缺性，顾名思义就是这个东西是有限的。用完了就没了，他就是稀缺的。或者说，这个东西只有这么多个，但是大多数人都想要它，它就是稀缺的。</p><p>比如年会有一台 iPhone, 所有人都想抽到给自己。这时候这个 iPhone 就是稀缺的。</p><p>这些比较实质的物体存在稀缺性比较好理解，但是还有一些无形的东西是不是也有稀缺性？</p><p>比如人与人之间建立联系和信任就是稀缺的。我们不会平白无故的相信一个陌生人，要获得这个稀缺就需要一定的付出。为什么很多商界大佬，还要去读 MBA，我想他们不是为了追求具体的知识，而是为了获取稀缺的高质量人际关系。</p><p>再比如，北上广深的房价，可以说是寸土寸金了。但是十八线小县城的房价却不那么贵。利用剪刀差，在北上广深工作个几年回家就能买套房。那为什么不同地理位置的价钱不一样？可以说是地理位置也是稀缺的。北上广深有稀缺的地理位置优势，所以他价值自然就高了。</p><h2 id="人是不会被满足的">人是不会被满足的</h2><p>说了几个上面关于稀缺的例子，也许就有人可以这么说：等每个人都变得富有了，都得到了现在想要的东西，就不会有那么多的稀缺了。或者说当想要这个东西的人，比东西的数量还要少的时候，就不存在稀缺了。</p><p>的确，如果有世界上有 60 亿台 iPhone，那么 iPhone 肯定不再稀缺了。得到一个物品后，对拥有他的人来说就不再稀缺了。当所有人都拥有这个东西，这个东西也自然就不存在稀缺性了。但人的欲望是无限的，当所有人都有了 iPhone 后我们就会想要性能更好，更与众不同的设备。</p><p>举个例子：我们生活中的空气不是稀缺的，每个生活在地球上的人都能获取到空气（这里不要抬杠说珠峰上的空气就是稀缺的了）。空气对大家来说不是稀缺的，但大城市里经常雾霾，人们就想要的去呼吸更清新的空气。虽然空气不稀缺，但是清新的空气却是稀缺的。</p><p>再比如，我们去吃自助餐的时候，总能比平时吃的更多。如果每天让你都这么吃话，应该都不会依旧胡吃海喝了。因为这时候食物不再是当前的稀缺，但是高级的食物会变成稀缺。我们会开始寻找更高级的自助餐厅。</p><p>我们总说穷人缺钱，等穷人变成了富人，又开始有富人说他们缺时间。总有毕业生说缺项目经验，等熬两年后又说缺管理经验了。</p><p>这些都是稀缺性在不断发生变化的过程。而其中有很大一部分是我们人为的在给自己提高标准。</p><p>我还看到过这么一个例子：有两种药，都能治好高血压的病。但是便宜一点的那个会有可能引发手抖的副作用。贵一点的进口药，则更加安全无副作用。但是仔细想想，手抖不抖和治疗高血压貌似没什么关系啊。但是大多数人为什么都选择相对更贵的药了？</p><p>从古至今，我们所知道的疾病数量越来越多，一方面是我们的医学技术越来越发达，还有一方面就是我们对健康的标准越来越高。「大多数的治疗是为了减轻痛苦，而不是为了救命」。</p><p>因为有欲望就会有需求，而欲望是无限的，需求也就不断地在变化。</p><h2 id="人工智能会让人闲下来么">人工智能会让人闲下来么</h2><p>现在有一个很热的概念叫人工智能，人类的所有劳动貌似都会被机器人替代。于是就有人担心以后会大规模的失业，失业就会有大量的无业游民，从而引发社会问题等。但人真的就会找不到事做么？</p><p>首先是大量无业游民这个问题。不可置否，有企业会逐步的淘汰掉一些简单的，重复性比较高的岗位。科技创新从研发到民用、商用的过程是很漫长的，更不会出现好像所有企业商量好了一样，同时开除大量的员工。因此大量无业游民这件事本身就不成立。</p><p>人工智能也是一种科技的进步，它也就是一个过程。也许我们现在就在这个时代进程的起点上，不把它放在足够长的时间轴上看。我们是感受不出来它对整体的影响。</p><p>其次是人会找不到工作吗？我在读完《人类简史》之后，看看我们整个人类的每一次科技变革。人们都有类似的担忧。</p><p>从狩猎时代过度到农耕时代时候，部落里的男人担心他们会失业了。因为以后就用不着他们去打猎了。反正不出去打猎也会有食物吃。可实际情况却是，整个部落的人变得更加忙碌。由原来的上午外出打猎，变成日出而作，日落而息。到了农耕时代，生活富足了，就有了更多的子嗣。人的需求不再只满足于今日份数的食物。而是想要今年存够明年的食物了。此时稀缺性发生了变化。</p><p>农耕时代变忙了，但总归还是有春播秋收的。一年中人还能休息上1个季节。工业革命开始时，也有人担心会失业了。因为有了机器设备能够大幅度提高劳动力。可是，人们的并没有因此而闲下来。人们开始进入工厂，工人们每天都需要在流水线上工作，目的就是为了满足人更大的需求。此时稀缺性发生了变化。</p><p>工业时代后，人们下班之后的生活还是属于自己的。等到了信息时代，大部分工人都不懂如何使用互联网，也开始担心会从此失业。但是实际情况就是：人们的上班时间和地点不再局限于工厂企业了。下班了也许QQ、微信、电话就会有老板联系你。此时稀缺性发生了变化。</p><p>那么等到了人工智能时代，我们会是什么样的？也许我们的需求会变成想要更加有效率的机器人；也许我们会想要找到更合适的能源供给给机器人；也许我们会开始追求美的东西，然后就想要有懂艺术的机器人。不管怎么样，那时稀缺性一定会发生了变化。</p><p>马斯诺很经典的「需求层次理论」说到：人的需求中，最低层次的是生理需求，但满足上一步之后，会逐步升级，直到去满足自我实现的需求。</p><p>所以我觉得，人并不会因为人工智能的到来而变得无所事事。反而会有更多的事需要我们去做。</p><p><strong>因为每个人都想得到一个有限的东西，同时由于人的欲望是无限的，并且还会不断提高需求，也就导致稀缺性的一直存在。</strong></p><h2 id="稀缺成就了市场">稀缺成就了市场</h2><p>前面说的穷人缺钱，富人缺时间。穷人成为富人稀缺性会出现变化。也是由于这种变化，导致了稀缺性在社会中的多样性。</p><p>因为社会上不只有这么一个人啊。别人富足的东西，但是你觉得稀有。别人稀有的，恰巧你比较富余。</p><p>于是就有了交易。比如有两个人，一个穷人、一个富人。富人想要用自己的时间去干其他事，那些需要花大量时间和精力的琐事他就可以请一个佣人来做。用自己比较富余的金钱去购买穷人比较富余的时间。至于要花多少钱，这就是市场决定的了。</p><p>你看，只有有人，就存在需求；只要有2个人以上，就存在稀缺的多样性；于是就产生了相互交易的行为。而<strong>交易某种物体或者服务的买者或者卖着组成的群体我们就叫市场</strong>。简单的说就是这群人组成了市场。有了市场就会存在经济问题。而经济学就是一门研究如何分配有限资源的学科。所以说，稀缺性才是经济学的非假设类的根基。</p><h2 id="保持自己的稀缺性">保持自己的稀缺性</h2><p>竟然是稀缺性成就了市场，市场的价值也就一定和稀缺程度想关。</p><p>放到我们工作上来说，我们的薪资不仅包含了自己的劳动价值。还有一大部分是我们的稀缺价值。想自己的薪资越来越高，提高自己的稀缺性是势在必行的。虽然站在风口的猪都能飞上天，但是从价值回归来看。只有提高自己的稀缺性，才能提高自己在市场上的价值。否则的话，风停了，摔死的还是猪。</p><p>到年底，总是希望能够升职加薪。首先我们都知道老板是不会为了已经失去的商品买单的。我们已经付出过的劳动就是他已经失去的商品。那么自己的工资就是对自己未来价值的体现。也就是说每一次谈薪资都是对你未来的价值进行重新评估。</p><p>那么，我们谈工资的时候，如果和老大去谈你之前如何付出、如何辛苦的话，就肯定是不管用的。工资是包含两部分的：<strong>无差别劳动的价值部分 + 稀缺性附加值部分</strong>。</p><p>想提高前部分，可以说这个工作薪资市场行情都已经比你高出很多了。但是这样谈薪资并不是适合我们的文化传统吧，给人一种要挟的感觉。</p><p>那么就只剩下稀缺性的附加值部分。因此提出你对未来的想法、计划。让人看到你这个人的稀缺性，不失为一条良策。</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
          <category> 随便写写 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 供需关系 </tag>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laya一个快速优化降低内存的方案</title>
      <link href="/2018/08/18/2018-08-18-Laya%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E4%BC%98%E5%8C%96%E5%B0%86%E4%BD%8E%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%A1%88/"/>
      <url>/2018/08/18/2018-08-18-Laya%E4%B8%80%E4%B8%AA%E5%BF%AB%E9%80%9F%E4%BC%98%E5%8C%96%E5%B0%86%E4%BD%8E%E5%86%85%E5%AD%98%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>layabox可以说只要从事过H5游戏开发的朋友们都听说过。H5渠道有很多好处，但是H5的用户付费能力一直也是一个痛点。由于LayaBox是支持打包app的。拿现有的游戏H5游戏去打包APP也不乏是一个好策略。但同时问题也随之而来，首当其冲的就是内存问题。</p><h2 id="问题分析">问题分析</h2><p>由于在H5游戏体验上来说，快速响应是需要考虑的主要问题。内存反而不那么重要。和一些朋友聊了之后，发现很多稍微偏重度一点的项目峰值内存经常在600甚至700M。问题其实很简单，如果光从对象这些内存来看，肯定是不会有这么大的。也就是说绝大部分内存是每个面板的资源，它们一直常驻在内存中没被释放。</p><p>很不幸我现在的项目就遇到了这么一个问题,项目到了后期，再去重构整个面板管理是不太实际了。<strong>寻找一个能快速降低内存的方案就是面板独一份自己的资源并且及时释放</strong>。也就是CPU换内存</p><h2 id="解决方案">解决方案</h2><ul><li>面板基类提供关闭完成方法和 打开面板前的reset方法（组件重新赋值skin值)。有面板自己进行override.</li><li>每个面板的小图资源打成合图，允许面板之间有重复资源</li><li>释放资源使用<code>Laya.loader.clearRes(url:String,true)</code>强制释放掉</li><li>每次开板需要重新加载到内存，并且重新设置所有空间对应的skin值</li><li>如果有必要，可以关闭laya的内部所维护的大合图功能。或者降低该宽高限制值（我记得默认是1024*1024，小于这个值得大图会被因为内部维护到一个大合图里而不能主动释放）</li></ul><h2 id="注意事项以及建议">注意事项以及建议</h2><ul><li>面板维护一个自己的panelResource对象，和panelPath路径。</li></ul><p>panelResource方便了加载和释放资源的操作。而panelPath则主要是针对一些UI面板是使用LayaAir进行编辑的页面。</p><p>简单的看一些引擎源码我们知道View是通过<code>createView</code>这个方法创建出来的。在需要重设组件skin的时候，这一类通过页面，我们可以递归该文件找出所有组件并对之重新赋值skin就OK了。能减少很多重复工作</p><ul><li>对List的没一个cell也需要进行reset操作。</li><li>需要处理List显示区域外的渲染问题。如果没有特殊需求。可以每次关闭面板的时候设置<code>list.array = []</code>;</li><li>组件的skin值 重设的时候需要设置成<code>skin = null</code>,否则不会生效。因为源码中skin的的set方法中，如果前后值一样是会被return的。</li><li>遇到所有资源感觉都被释放后，依旧有很大的内存泄漏。检查一下是不是开启了引擎的大合图功能。可以关闭或适当降低限制数值</li><li>如果使用了对象池。对象回收放入对象池的之前，先把所有属性设置成默认状态，并且释放掉对应的图片资源。（除非资源比较小）</li><li>场景切换可以考虑释放前一个场景的资源，包括例如释放item道具资源，主城常驻资源等。根据实际情况考虑</li></ul><h2 id="最后">最后</h2><p>这里只是一个救急的方案，适合在立项之初没有考虑过内存的问题，之后控制内存需求的项目。相信有了一次教训后，之后的项目会在开始的时候，就应该考虑的更全面，写出更优化的项目结构。</p><p>同时内存优化也只是项目优化的一部分，在体验上和效率上找到一个平衡。而项目优化也是一个持续的过程，不单单都是程序上的优化。特效，UI切图，甚至策划层面都是可以的。比如说骨骼数，序列帧数，面板层级数等等。与其说优化，不如说是利用现有的各类资源和成本，把产品做到最舒服的一个过程。共勉！</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 逻辑及优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LayaBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计模式（4）-组件模式</title>
      <link href="/2018/03/19/2018-03-19-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/03/19/2018-03-19-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%884%EF%BC%89-%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>近期在折腾一个和车有关的项目，写完总想着手去优化一下代码结构。毕竟相信策划说的话一定是慢性自杀的过程。</p><h2 id="需求举例">需求举例</h2><p>玩家控制车辆在地图上行驶，当车辆经过某特殊的点，会回复用于释放技能的能量点。并播放一系列能量回复的动画。为了简单这里只讨论车这个实例，至于技能和buff系统这里不考虑。</p><h2 id="较笨的方法">较笨的方法</h2><p>这里赛车的表现依赖玩家的输入特殊位置点，同时有一个与数据无关的动画展示。对比之前我们说的update方法。可以把在每一帧中将这一系列的操作都写在这个update方法中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vehicle():_v(<span class="number">0</span>),_x(<span class="number">0</span>),_y(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(Physics &amp; phy, Animation &amp; ani)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(PlayerInput::getInput())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>:PRESS_UP:</span><br><span class="line">_v += CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>:PRESS_DOWN:</span><br><span class="line">_v -= CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_x += _v;</span><br><span class="line">_y += _v;</span><br><span class="line"></span><br><span class="line">_enemy = phy.setPostion(spos,_x, _y);<span class="comment">//检测是否经过</span></span><br><span class="line"><span class="keyword">if</span>(enemy &gt; <span class="number">0</span>)</span><br><span class="line">ani.play(*ske_up,_x,_y);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ani.play(*ske_down,_x,_y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONST_NOMAL_VA = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> _v, _x, _y;</span><br><span class="line"><span class="keyword">int</span> _enemy;</span><br><span class="line"></span><br><span class="line">Skeleton ske_up;<span class="comment">//能量&gt;0时的动画</span></span><br><span class="line">Skeleton ske_down;<span class="comment">//能量&lt;0时动画</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>咋一看逻辑清晰，但是将输入、能量点位置计算、动画都写在一个方法里头肯定是不可取的。这段代码不过是因为忽略所有细节不复杂才显得比较清晰。当以后需要提供添加其他细节，或者新手教学的自动演示等，这一段代码的肯是会越来越长，最后难以维护的。那么现在先来看看如何利用<strong>组件模式</strong>一步步的改写。</p><h2 id="改进之后">改进之后</h2><h3 id="组件模式是什么">组件模式是什么</h3><p>将主角实例看成是一个容器，容器内有不同的组件进行拼装。实现一个实例内的不同模块相互分离，达到降低耦合的作用。</p><h3 id="组件模式适合场景">组件模式适合场景</h3><ol><li>当某实例需要使用多个不同模块的类，且希望他们之间保持相互隔离。</li><li>无法通过继承达到定位使用不同的模块时。那就将它们设计成组件</li></ol><h3 id="第一步：分离组件">第一步：分离组件</h3><p>这一步其实比较简单，只需要将不同的模块独立出一个类，同时将Vehicle实例的引用传递给不同组件类。例如将玩家输入部分分离之后的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputCompent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(Vehicle &amp; vehicle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(PlayerInput::getInput())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>:PRESS_UP:</span><br><span class="line">vehicle._v += CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>:PRESS_DOWN:</span><br><span class="line">vehicle._v -= CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONST_NOMAL_VA = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对其他的Physics和Animation也采取同样的方式。最后Vehicle类将简化成只需要容纳不同组件的一个容器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Vehicle():_v(<span class="number">0</span>),_x(<span class="number">0</span>),_y(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Physics &amp; phy, Animation &amp; ani)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    _input.update(*<span class="keyword">this</span>);</span><br><span class="line">    _physics.update(*<span class="keyword">this</span>, phy);</span><br><span class="line">    _animation.update(*<span class="keyword">this</span>, ani);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">InputComponent _input;</span><br><span class="line">PhysicsComponent _physics;</span><br><span class="line">AnimationComponent _animation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="第二步：抽象组件">第二步：抽象组件</h3><p>有了上面的改写之后，整个实例只关心自己需要的哪些组件和组件共享的数据:<em>_v,_x,_y</em>,但是每个组件的具体行为还是可以直接从实例Vehicle中得知。如何再次将组件抽象出来呢?比如当需要设计一个演示操作，或者测试用例的时候，就需要一个模拟的用户输入。如果将上一步的组件抽象成一个接口，将现有的输入代码放入接口的实现中，这样只需要将演示输入继承自设计好的抽象类即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComponent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//输入组件抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~InputComponent() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vehicle&amp; vehicle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayerInputComponent</span> :</span> <span class="keyword">public</span> InputComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vehicle&amp; vehicle)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line"><span class="keyword">switch</span>(PlayerInput::getInput())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span>:PRESS_UP:</span><br><span class="line">vehicle._v += CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span>:PRESS_DOWN:</span><br><span class="line">vehicle._v -= CONST_NOMAL_VA;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONST_NOMAL_VA = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> _v, _x, _y;</span><br><span class="line"></span><br><span class="line">Vehicle(InputComponent* input): _input(input)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Physics &amp; phy, Animation &amp; ani)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_input.update(*<span class="keyword">this</span>);</span><br><span class="line">_physics.update(*<span class="keyword">this</span>, phy);</span><br><span class="line">_animation.update(*<span class="keyword">this</span>, ani);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  InputComponent _input;</span><br><span class="line">  PhysicsComponent _physics;</span><br><span class="line">  AnimationComponent _animation;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见问题与解决方案">常见问题与解决方案</h2><h3 id="组件的获取方式">组件的获取方式</h3><blockquote><p>外部创建组件</p></blockquote><p>这个方式是得组件对象更加灵活，可以不同的复用。但是需要处理是否链接一些必要的组件防止出错</p><blockquote><p>对象本身创建组件</p></blockquote><p>这个方式不用关心组件的链接正确与否，但是需要有一个外部控制这个对象，否则组件这和对象内的方法没啥区别吧</p><h3 id="组件之间的通信方式">组件之间的通信方式</h3><blockquote><p>修改容器对象的属性。这就意味着容器对象需要保留组件公用的变量。</p></blockquote><blockquote><p>发送消息</p></blockquote><p><strong>如果我们有现成的消息系统直接使用即可</strong>。也可以在内部维护一个小的消息系统.<strong>Component(消息接口) + InputComponent（抽象组件接口） – PlayerInputComponent（组件接口实现）</strong>。这里Component和InputComponent都为抽象类，为同级关系。然后再容器中提供发送消息的方法，对容器内所有组件调用receive方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(<span class="keyword">int</span> msg)</span> </span>= <span class="number">0</span>;<span class="comment">//组件会实现接受消息的方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputComponent</span>:</span> <span class="keyword">public</span> Compent, <span class="keyword">public</span> InputComponent</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输入组件抽象类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~InputComponent() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vehicle&amp; vehicle)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>组件之间互相引用（不推荐）</p></blockquote><p>这个方法其实就有退步的嫌疑了，本身我们的设计目的就是为了降低各个组件之间的耦合性。因此不推荐</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计模式（3）-状态模式</title>
      <link href="/2018/03/02/2018-03-02%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/03/02/2018-03-02%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%883%EF%BC%89-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>迷上了“吃鸡”的手游，哈哈哈哈哈。关于射击类的游戏，今天来说一下主角的一种设计方式。</p><h2 id="需求举例">需求举例</h2><p>一般射击类的主角有<strong>跳，蹲下，站立</strong>三种静止状态。有步行，冲刺两种移动状态。同时可以在跳跃和移动状态中进行开火。需要实现当按下A开始跳，B蹲，松开B站起来，C步行，D冲刺，E开火。</p><h2 id="较笨的做法">较笨的做法</h2><p>先看3个静止状态的实现，最简单的方法用一个条件判断来完成这个操作跳跃动作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(input == PRESS_A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isJump)</span><br><span class="line">&#123;</span><br><span class="line">isJump = <span class="literal">true</span>;<span class="comment">//防止在空中继续跳</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">doJump();<span class="comment">//跳跃方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>（input == PRESS_B）<span class="comment">//按下B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isJump)</span><br><span class="line">doDuck();<span class="comment">//执行蹲下</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(input == RELEASE_B)<span class="comment">//松开B</span></span><br><span class="line">&#123;</span><br><span class="line">doStand();<span class="comment">//执行站立</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码仔细看貌似没问题。但是，如果玩家先蹲下来。执行了doDuck方法。然后再次按下A跳起来执行doJump方法。在空中的时候释放B，就会执行doStand()方法.而在空中是不应该出现站立的状态的。所以我们还得为添加一个bool变量来控制是否在蹲下状态。<strong>也就是说我们每次添加一个状态就需要为这个状态添加一个bool变量来对其进行约束</strong>，在往后加走，冲刺那么这份代码就变得越来越难以维护。再往后想，如果切换弹夹的时候还需要个计时器，这时候各个状态之间变得更难维护了。我们希望的是每个状态只关心当前状态的操作。<strong>把当前状态有关的代码和数据封装起来</strong>。所以，对于需要各个状态来回切换的情景，有了一个设计模式为：<strong>状态机模式</strong></p><h3 id="有限状态机">有限状态机</h3><p>应对场景：</p><ol><li>在一组有限的状态之间进行切换</li><li>每次只能处于一种状态</li><li>状态会接受一组输入或者事件来触发状态机改变</li></ol><h2 id="改进之后">改进之后</h2><p>首先我们定义一个状态基类。其他主角的每一个状态都继承与这个状态基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//首先我们定义一个状态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~HeroState()&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(Hero &amp;hero， Input input)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Hero &amp;hero)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Hero &amp;hero)</span></span>&#123;&#125;<span class="comment">//进入该状态需要执行的逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Hero &amp;hero)</span></span>&#123;&#125;<span class="comment">//退出需要执行的逻辑</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现某个特定状态的类 继承自基础状态类</span></span><br><span class="line">Class JumpState: <span class="keyword">public</span> HeroState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">JumpState():_jumpTime(<span class="number">0</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(Hero &amp;hero， Input input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(input == PRESS_A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//更改状态,采用静态方式存储各个状态。</span></span><br><span class="line">hero._state = &amp;HeroStae:jumping;</span><br><span class="line">hero.doJump();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Hero &amp;hero)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( _jumpTime &gt;= MAX_TIME)</span><br><span class="line">hero.doJumpTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Hero &amp; hero)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hero.doJump();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">enter</span><span class="params">(Hero &amp; hero)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">hero.doJumpExit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> _jumpTime;<span class="comment">//用于模拟跳跃时间触发某事件，将每个状态的时间独立在状态类内部</span></span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义主角类中的指针变量，指向当前状态。由这个指针去调用当前状态的更新方法实现状态内部的控制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(Input input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_state -&gt; handleInput(*<span class="keyword">this</span>, input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">_state -&gt; update(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> HeroState *_state;<span class="comment">//这个变量用于修改当前状态即可完成状态的切换。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们为这些不同的状态创建了各自的类，但这些类没有实例化。在上面的代码中我们采用静态数据存储各个状态，在状态基类中添加。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroState</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//添加静态状态代码</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> JumpState jumping;</span><br><span class="line"><span class="keyword">static</span> DuckState ducking;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们还可以采用实例化的方式进行。这适合在有多个主角的情况下。需要为特定的主角创建独一份的状态。正好符合实例化的胃口呀。每次更新状态后，我们需要删除掉之前的状态。于是，我们可以修改状态类中的handleInput()方法，为它添加一个返回值，<strong>主角可以删除掉之前的状态实例，引用返回的新的状态实例</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Class StandState: <span class="keyword">public</span> HeroState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> HeroState* <span class="title">handleInput</span><span class="params">(Hero &amp;hero， Input input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(input == PRESS_B)<span class="comment">//站立状态下直接按下B</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> DuckState();<span class="comment">//返回新的状态实例</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改主角类使用方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(Input input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HeroState: state = _state -&gt; handleInput(*<span class="keyword">this</span>, input);</span><br><span class="line"><span class="keyword">if</span>(state != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> _state;<span class="comment">//释放之前的状态实例</span></span><br><span class="line">state -&gt; <span class="built_in">exit</span>();<span class="comment">//执行状态退出需要执行的动作</span></span><br><span class="line">_state = state;<span class="comment">//重新赋值新的状态</span></span><br><span class="line">_state -&gt; enter();<span class="comment">//更新状态需要执行的动作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这，基本的状态模式框架已经完成。我们只需要控制各个状态之间的切换编码。同时状态只关心自己内部的逻辑。与之前的<em>笨方法</em>相比较，这样的可维护性是高多了。</p><h2 id="常见问题以及解决办法">常见问题以及解决办法</h2><h3 id="并发状态机">并发状态机</h3><p>我们知道在吃鸡这类射击游戏中，我们经常需要走位边进行射击。都拿着AK47对点可不希望自己当靶子。那么这时候就会出现在持枪开火状态下可以存在另外一个移动的状态，或者跳跃状态（传说中的跳狙）。这样一来之前的状态需要翻倍。似乎又变成了之前的笨方法的怪圈。那么如何解决呢？<br><strong>2333,其实只需要新定义1个状态机，在主角类添加一个新的引用用于保存新的状态机即可</strong>。在主角的输入情况下为两个状态进行时间派发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hero</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> HeroState *_state;</span><br><span class="line"><span class="keyword">private</span> HeroState *_stateGun;<span class="comment">//新的开火状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态的优先级">状态的优先级</h3><p>设计中一般会有这样的需求，在任何状态按下A，都必须立马蹲下。这里可以添加一个中间类GroundState，继承我们的状态基类HeroState。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroundState</span> :</span><span class="keyword">public</span> HeroState</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在这里处理输入对应的状态的优先级。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleInput</span><span class="params">(Hero &amp;hero， Input input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(input == PRESS_A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(input == PRESS_B)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他状态类继承自GroundState</span></span><br><span class="line">class StandState:<span class="keyword">public</span> GroundState</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">virtual</span> <span class="keyword">void</span> handleInput(Hero &amp;hero， Input input)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(input == RELEASE_B)</span><br><span class="line">&#123;</span><br><span class="line">hero._state = &amp;HeroStae:standing;</span><br><span class="line">hero.doStand();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">GroundState::handleInput(hero,input);如果这里不处理，那么则交给该类的父类进行处理</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用栈结构记录上一个状态">使用栈结构记录上一个状态</h3><p>当我们开火之后，我们需要回到之前开火的状态。那么就有了需要记录上一个状态的需求。我们知道栈的结构是先进后出。也就是我们当前的状态一定是在栈顶的，当我们切换状态之后，新的状态会被压入到栈顶，之前的状态成为了栈顶的下一个元素。当需要回到上一个状态的话，只需要将当前状态pop出栈。上一个状态就会成为当前状态。多么很方便~~</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计模式（2）-对象池</title>
      <link href="/2018/02/20/2018-02-20-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89-%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
      <url>/2018/02/20/2018-02-20-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%882%EF%BC%89-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.jianshu.com/p/a16e8cd25213" target="_blank" rel="noopener">上一篇</a>我们提到了在使用很多个对象需要进行相同计算的时候，可以在内部维护一个update方法，让其自己更新自己的数据约行为模式。这样降低了了每个对象之间的耦合性。但假设这些对象还需要经常的被销毁。就例如上次提到例子中，N辆警车现在在可以被玩家操作的劫匪干掉。而且劫匪厉害的很，可以整片整片的把警车对象销毁。再例如我们游戏中常见的粒子特效。这些对象都需要快速的生成和销毁。这样的内存操作在这种情景下就会变得非常频繁。今天就来探讨一下这一类的问题的合适的做法应该是怎么样的。</p><h2 id="需求举例">需求举例</h2><p>劫匪可以销毁大量的警车。同时主场景会不断的出现新的警车。（假设这个警车数量会很大。这里就不用粒子特效来举例子）</p><h2 id="最笨的办法">最笨的办法</h2><p>很简单的一个做法其实就是需要的时候new生成一个，不需要的时候delete销毁一个。当然，这样的代码看起来很直接。但是这样带来的问题也是很麻烦的。伪代码大概可以是这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">timeLoop.create(<span class="number">1000</span>,function()&#123;</span><br><span class="line">vehicle = <span class="keyword">new</span> vehicle();<span class="comment">//固定2秒创建一个</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(vehicle.isDie）</span><br><span class="line">vehicle.destory();<span class="comment">//死亡则释放对象</span></span><br></pre></td></tr></table></figure><p>我们都知道我们的对象在堆上生成，内存地址计算机内部是连续的。这里假设我们有30字节的空闲内存可以使用，然后我们依次创建了ABC三个对象分别占用了8、12、8字节，然后释放掉对象A和C各所占用的8字节内存，再去创建一个对象D的需要10自己的时候就会因为内存不足导致失败。这就是内存碎片。如下图所示：<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E9%97%AE%E9%A2%98.png" alt=""></p><h2 id="改进之后">改进之后</h2><p>不仅仅有上述说的内存碎片的问题，同时内存的分配也是相当缓慢的。虽然这些问题在现如今的硬件过剩的年代看不出多大的问题。但是你可以把它写的更好，这就是要说的对象池模式。</p><p>由我们自己定义一个保持可<strong>重用对象集合的对象池类</strong>，维护好每个对象的使用状态，其中的每个对象支持状态访问。初始化这个对象池的时候，会预先创建一个整块内存（通常为连续的堆区），当需要生成对象的时候，从对象池内取出一个未使用的对象。当对象被释放的时候，返回到对象池</p><p>在游戏启动（或者这个模块启动）的时候分配一个大块内存，在游戏结束（或者这个模块结束）的时候释放掉这一整块内存。在开始的时候就立马分配一大块内存，对系统也是一个负担，这个取舍就取决于你的对象是否需要频繁的进行创建和销毁。因此内存池的适用情境一般为：</p><ul><li>需要频繁的创建和销毁对象</li><li>对象大小一致时</li><li>对象内封装了获取代价较高的资源（因为每次创建都需要付出较高的代价去获取内部所需要的资源)</li></ul><p>结合上篇文章的update模式可以写成如下的伪代码：create方法通过外部代码调用来创建新的车辆。游戏通过计时器每次调用对象池内的run方法。他会调用每个对象自身的run方法来更新自己状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VehiclePool</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="keyword">int</span> carid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">100</span>;</span><br><span class="line">Vehicle vehicles[MAX_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> VehiclePool:create(<span class="keyword">int</span> carId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vehicles[i].isUse)<span class="comment">//检查这个对象是否被使用中</span></span><br><span class="line">&#123;</span><br><span class="line">vehicles[i].init(carId);<span class="comment">//初始化这个对象</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> VehiclePool:run()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">&#123;</span><br><span class="line">vehicles[i].run();<span class="comment">//调用车自身的run方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见问题以及解决方案">常见问题以及解决方案</h2><p>在我们拥有了垃圾回收机制的时候，我们通过new delete就可以进行内存管理，但是当我们使用内存池的时候，其实是在告诉系统，这一块内存内部的管理由程序员自己接管了。</p><h3 id="对象池是过大或过小">对象池是过大或过小</h3><p>对象池的太大。很明显的是浪费了内存。而对象池过小呢，在重用某个对象时，可能会因为对象池内的对象都在使用状态中，而导致重用对象失败。对于这个问题，也是看实际情况中，如果是粒子系统中，那么少一个粒子对象也许并不会察觉到，可以选择当所有对象都在使用状态中，直接<em>不创建对象</em>或者检索一个最不起眼的对象<em>将其回收到对象池中</em>，供下个对象使用。再者就是重新评估对象池的大小是否真的合适，可以考虑直接扩充大小。或者曾泽一个二级溢出池。当全部被使用（或者使用情况达到某个状态)的时候将其启用。</p><h3 id="对象的引用没有及时清理干净">对象的引用没有及时清理干净</h3><p>对象池内的对象不再使用的时候，依旧是占用内存，只是会收到了对象池内，这时候这个对象依旧可以持有其他引用。拿奖会引起很多不必要的麻烦。并且由于是我们接管了这一块内存的管理方式，GC这种东西对这一块内存是无能为力了的。因此，<strong>当对象池中的对象被回收的时候，必须情况这个对象指向其他任何对象的引用</strong></p><h3 id="不要在对象池内存入大小不一的对象">不要在对象池内存入大小不一的对象</h3><p>这个道理其实比较简单，但是还是需要在使用中注意。不然就会出现在在对象池中的最小单位必须为内存池中最大的那个对象的大小。这把背包放到行李箱中去做地铁上班（浪费内存，费力不讨好);</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏设计模式（1）-update方法</title>
      <link href="/2018/02/04/2018-02-04-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89-update%E6%96%B9%E6%B3%95/"/>
      <url>/2018/02/04/2018-02-04-%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%881%EF%BC%89-update%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>系统的扩展是开发中十分常见的。因此使用一个合理的设计模式十分必要。这篇文章先看一个常见的update更新方法的思路。在实际的游戏开发时，常常会有一系列的对象需要同步地运转。比如有N个怪物需要同时做一个动作方案，N辆车需要同时从赛道的起点跑到终点。而这些对象直线之间又是相互独立的存在。</p><p>总结上面的情况大概可以归纳为：</p><ul><li>对象的行为与时间相关（最短可以到每一帧）</li><li>各个对象的行为相互独立</li></ul><h2 id="需求举例">需求举例</h2><p>有一辆警车需要在路口A来回进行巡逻。为了游戏体验，还需要每一帧都移动</p><h2 id="最笨的方法">最笨的方法</h2><p>直接从需求上看，我们可以依赖外部的游戏循环进行迭代，可以开启一个帧循环计时器。将该警车vehcile定在某个坐标范围内，然后通过坐标的位置进行反向，以实现来回巡逻的需求。代码上可以简单写成如下形式（简单的假设只在X方向进行移动）。先看代码，然后再说为何这么做是最笨的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool runLeft = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）<span class="comment">//模拟游戏的帧循环</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(runLeft)</span><br><span class="line">&#123;</span><br><span class="line">x--;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line">runLeft = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">x++;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">100</span>)</span><br><span class="line">runLeft = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">vehcile.x = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进之后">改进之后</h2><p>以上代码看起来是符合了当前的需求，这里警车可以来回进行巡逻了。可是，别忘了策划是随时会改的，当哪天说需要给这个警车附加一个技能，比如遇到需要持续的释放钉刺带之类的。或者需要更多这样类似的警车。这时候将会在以上的代码加入一个计入当前帧数的变量，然后需要加入N个判断（这取决策划给了你多少个释放的时机）。这样一来，上面的代码的<strong>可维护性就变得很低很低</strong>了。我们会不可避免的在这个循环里加入大量的逻辑控制代码。为了解决这个问题，有了这篇文字要说的一个游戏常用的设计模式：这里叫它为<strong>update方法</strong></p><ul><li>游戏维护一个对象的集合</li><li>每个对象实现一个更新方法</li><li>游戏循环每帧对集合内所有对象调用其更新方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;vehciles.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">((vehcile *)vehciles[i]).run();<span class="comment">// 游戏循环每帧对集合内所有对象调用其更新方法。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在run方法里面实现该vehcile的具体逻辑，只要将最笨的那个方法移到对象内部的run方法里头。</span></span><br></pre></td></tr></table></figure><h2 id="常见问题的解决方案">常见问题的解决方案</h2><h3 id="该模式的增加和删除对象。">该模式的增加和删除对象。</h3><p>由于将大量的游戏表现需要在更新方法中完成，通常就会存在删除对象，增加对象等操作。当产生一个新对象的时候，直接添加到游戏循环维护的对象集合末尾中，这里有可能出现<strong>在对象产生的那一帧中进行更新，而此时玩家并没有看到该对象</strong>。当移除某对象的时，正好这个对象位于你当前的更新对象之前。那么也会存在<strong>掠夺下一个对象</strong>,因为当前正在更新下标为1的对象B，然后这时候下表为0的对象A被移除，原来下标为2的对象C，现在变成了1，下标原本为3的D变成了2。当进行下一个对象更新的时候，就直接跳过了对象C。如下图：<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E6%9B%B4%E6%96%B0%E6%96%B9%E6%B3%95%E5%AF%B9%E8%B1%A1%E8%A2%AB%E8%B7%B3%E8%BF%87.png" alt=""><br>那么增加和删除对象分别该如何处理呢</p><blockquote><p>添加对象： 一般是在遍历之前存储对象集合的长度.以保证这一帧的循环在任何新增的对象之前停止。</p></blockquote><blockquote><p>删除对象： 将移除方法放在这一帧的的循环结束之后，要被移除的对象标记成“待移除”，在跟新期间跳过该对象。在结束的时候启动一个遍历移除这些移除这些对象的操作</p></blockquote><h3 id="未被利用的对象如何处理">未被利用的对象如何处理</h3><p>在实际的游戏场景中，一定会纯在一些游戏对象暂时不需要被更新。如果存在大量的这种暂时不被更新的对象。每一帧都去调用它的更新方法。将会浪费很多CPU的时间去做这些无用功。</p><p>**解决方案：**单独维护一个需要被更新的对象列表。当一个对象被暂时为“不需要更新”的状态时，将其从该列表中移除。当被重新启用时重新添加。至于添加和删除需要注意的地方在4.1中已经说明啦。</p><p>上面这么做的思路无非就是<strong>空间换时间</strong>,因为需要使用额外的内存去维护这两个列表。还需要一个列表来维护所有的对象。同时这些集合一定需要实时同步。</p><p>因此这需要看具体的非活跃对象的数目，数目越多，就越需要一个单独的集合来做处理。</p><p><em>这个模式还是比较简单的，后续会把自己在开发过程遇到的一些问题总结出来。从实际使用中学习使用合理的设计模式</em></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程与GCD</title>
      <link href="/2018/01/01/2018-01-01-IOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EGCD/"/>
      <url>/2018/01/01/2018-01-01-IOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8EGCD/</url>
      
        <content type="html"><![CDATA[<p>通俗来说就是可以同时做N个事情。不用等待上一步的完成状态形成阻塞、例如在交互等操作和大文件读取操作在不同线程进行。可在执行保证长时间的文件处理时依旧能保证用户的响应。</p><h2 id="多线程概述">多线程概述</h2><p>从第一次接触计算机编程会用C语言写HelloWorld的时候开始，就被告诉代码通过编译、链接最终形成可执行代码（可执行文件）。而这些可执行的代码在机器上执行时，必然是有序的一条一条的执行<strong>CPU命令列</strong>。几遍遇到for循环或者goto这样的语句。<strong>命令列</strong>也不是出现分叉口而同时执行。</p><blockquote><p>上面的是典型的单线程，那如何在多条路径中执行CPU命令列呢？</p></blockquote><ol><li>上下文切换：保存CPU当前的寄存器等信息到不同命令列的内存中。由系统控制每固定时间间隔进行一次复原操切换的操作</li><li>使用多核CPU。</li></ol><p>前者是给你看起来像多线程处理信息。后者则是真正的多线程。<br>在OC中多线程进行开发的技术有很多，这篇主要讲常用的GCD。子所以大家更愿意用GCD，先看下各个多线程技术之间的特点比较：<br><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E7%9A%84%E6%AF%94%E8%BE%83.png" alt=""></p><h2 id="GCD-API总结">GCD_API总结</h2><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E4%B8%B2%E5%B9%B6%E8%A1%8C%E7%9A%84%E5%BC%82%E5%90%8C.png" alt=""></p><p>在GCD的官方说明中：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>&#123; queue, ^&#123;</span><br><span class="line"><span class="comment">//想执行的任务</span></span><br><span class="line">&#125;）;</span><br></pre></td></tr></table></figure><p><strong>开发者要做的只是定义想执行的任务追加到Dispatch_queue中</strong><br>那么这个Dispatch_queue其实就是一个执行任务的等待队列（先进先出）<br>而队列分为串行（Serial Dispatch Queue）和并行（Concurrent Dispatch Queue）两种。</p><h3 id="创建Dispatch-queue">创建Dispatch_queue</h3><blockquote><p>dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)；</p></blockquote><ul><li>参数1:该Dispatch_queue的标识符，用于线程调试（比较多线程容易造成更累问题，例如不同进程访问相同一份数据）</li><li>参数2:队列类型。创建串行设置成<strong>DISPATCH_QUEUE_SERIAL</strong>或<strong>NULL</strong>即可。创建Concurrent Dispatch Queue设置成<strong>DISPATCH_QUEUE_CONCURRENT</strong></li></ul><p>除了每次创建，还可以通过系统提供的Disptach Queue。</p><h3 id="Main-Dispatch-Queue">Main Dispatch Queue</h3><p>在主线程的中执行，属于串行类型。会追加到主线程的RunLoop中执行。主要用户界面刷新操作一般放在该队列中执行。</p><blockquote><p>获取方式：dispatch_get_main_queue();</p></blockquote><h3 id="Global-Dispatch-Queue">Global Dispatch Queue</h3><p>属于并行类型，拥有四个优先级。获取方式分别为：</p><blockquote><p>最高优先级：dispatch_get_goobal_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);</p></blockquote><blockquote><p>默认优先级：dispatch_get_goobal_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p></blockquote><blockquote><p>低优先级：dispatch_get_goobal_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);</p></blockquote><blockquote><p>后台优先级：dispatch_get_goobal_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);</p></blockquote><h3 id="变更优先级">变更优先级</h3><p>默认创建的任何Dispatch Queue的优先级都是属于默认为DISPATCH_QUEUE_PRIORITY_DEFAULT。变更优先级的方法为：</p><blockquote><p>dispatch_set_target_queue(dispatch_queue_t queue1, dispatch_queue_t queue2);</p></blockquote><ul><li>参数1：需要设置的dispatch queue</li><li>参数2：需要设置的参照dispatch queue</li></ul><h3 id="延迟加入到线程中">延迟加入到线程中</h3><p>这里延迟加入和延迟执行为2个概念。加入延迟3秒加入到一个串行Dispatch queue中，而该Dispatch queue中还有很多没处理完的任务。那么久这个时间就会&gt;3秒。</p><blockquote><p>dispatch_after(dispatch_time_t time, dispatch_queue_t queue, ^{});</p></blockquote><ul><li>参数1：为延迟追加的时间</li><li>参数2：为需要追加的Dispatch queue</li><li>参数3：为需要执行的处理动作</li></ul><p>对于第一个参数的类型也有对应的生成办法</p><blockquote><p>dispatch_time_t(dispatch_time_t time, unsinged long long t);</p></blockquote><ul><li>参数1：为指定的开始时间</li><li>参数2：为到t时间之后。</li></ul><p>例如:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示从当前时间开始3**秒**后的时间</span></span><br><span class="line">dispatch_time_t（DISPATCH_TIME_NOW, <span class="number">3</span>nul * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">//表示从当前时间开始300**毫秒**后的时间</span></span><br><span class="line">dispatch_time_t（DISPATCH_TIME_NOW, <span class="number">300</span>nul * <span class="built_in">NSEC_PER_MSEC</span>);</span><br></pre></td></tr></table></figure><h3 id="多个处理结束的回调">多个处理结束的回调</h3><p>1、如果是只使用一个串行Dispatch queue，只需要在将希望执行的处理放在最后<br>2、使用多个Dispatch queue或者使用多个并行Dispatch queue。则需要使用Dispatch Group来轻松实现该需求。</p><blockquote><ol><li>dispatch_group_create();//创建Dispatch Group</li></ol></blockquote><ul><li>ispatch Group 与 Dispatch queue相同</li></ul><blockquote><ol start="2"><li>dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, ^{});//添加到Group</li></ol></blockquote><ul><li>参数1：需要追加到的Dispatch Queue</li><li>参数2：需要执行的处理动作</li></ul><blockquote><ol start="3"><li>dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, ^{});//注册需要执行的动作到目标线程</li></ol></blockquote><ul><li>参数1：指定需要监听的group</li><li>参数2：被追加需要执行动作的Dispatch Queue</li><li>参数3：期望参数1group内全部执行处理结束后的回掉操作</li></ul><blockquote><ol start="4"><li>dispatch_group_wait(dispatch_group_t group,dispatch_time_t time);//time时间内等待全部处理执行结束返回0。</li></ol></blockquote><ul><li>参数1：指定需要监听的group</li><li>参数2：等待时间。设置成DISPATCH_TIME_FOREVER为永久等待。</li></ul><h3 id="线程提供阻塞等待">线程提供阻塞等待</h3><p>由于线程之间会导致数据竞争等问题。例如在读取和写入的操作上就会存在读取和写入的并行执行产生冲突。解决方式有：<br>1、使用串行Dispatch queue。<br>2、读取不与写入处理并行执行。<br>3、使用dispatch_barrier_async。<br>这里第三种解决办法是GCD提供的一个较为方便的方式。可以等到插入的位置之前所有操作完成之后，在执行插入的处理，当插入的处理操作执行结束后，再恢复之前的操作。具体示意图如下：</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/dispatch_barrier%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><blockquote><p>dispatch_barrier_async(dispatch_queue_t queue, ^{});</p></blockquote><ul><li>参数1:需要插入到的dispatch queue</li><li>参数2:需要插入的操作</li></ul><h3 id="线程同步">线程同步</h3><blockquote><ol><li>dispatch_sync（dispatch_queue_t queue, ^{});//等待追加的Block执行结束</li></ol></blockquote><ul><li>参数1：需要追加的Dispatch queue</li><li>参数2：需要执行的处理动作</li></ul><p>由于等到到当前线程停止，那么就很容易导致“死锁”问题。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;<span class="built_in">NSLog</span>(<span class="string">"hello world"</span>);&#125;);</span><br></pre></td></tr></table></figure><p>主线程中执行Block，并等待其执行结束。而主线程正在执行这些代码。无法执行该Block。</p><blockquote><ol start="2"><li>dispatch_apply(UInt iterations,dispatch_queue_t queue, ^{});//按将Block指定次数iterations追加到queue中。</li></ol></blockquote><ul><li>参数1：重复次数</li><li>参数2：追加对象的Dispatch Queue</li><li>参数3：追加的处理Block</li></ul><p>使用这个特性可以模拟一个for循环对一个array类对象的所有元素执行处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_PRIORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line">dispatch_apply([array count] queue ^(size_t index)&#123;<span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[array objectAtIndex:index]);&#125;);</span><br></pre></td></tr></table></figure><h3 id="挂起和恢复Dispatch-Queue">挂起和恢复Dispatch Queue</h3><p>当希望已追加到Dispatch Queue的操作不执行时，可以直接dispatch_suspend挂起该Dispatch Queue。然后再在适当的时机通过dispatch_resume来回复该Dispatch Queue。</p><h3 id="信号量控制并发">信号量控制并发</h3><p>一般开发中，当线程数量达到一定数量后，会使用NSOperationQueue来控制并发。而在GCD中采用的是Dispatch Semaphore。先来看信号量的概念：</p><blockquote><p><em>信号量</em>是一个整型值，且有一个初始计数值。支持<strong>信号通知</strong>与<strong>信号等待</strong>。当一个信号量被信号通知，其计数会被增加。当一个线程在一个信号量上等待时，线程会被阻塞，直至计数器大于零，然后线程会减少这个计数。</p></blockquote><ul><li>计数 == 0：等待</li><li>计数 &gt;= 1：减1不等待</li></ul><p>在GCD中：</p><blockquote><p>dispatch_semaphore_create（int)　　　创建一个semaphore</p></blockquote><ul><li>参数1：初始化的计数值</li></ul><blockquote><p>dispatch_semaphore_signal(dispacth_semaphore_t semaphore)　　　发送一个信号</p></blockquote><ul><li>参数1：需要派发的semaphore</li></ul><blockquote><p>dispatch_semaphore_wait(dispacth_semaphore_t semaphore, dispatch_time_t time)　　　等待信号</p></blockquote><ul><li>参数1：semaphore</li><li>参数2：等待时间。设置成DISPATCH_TIME_FOREVER为永久等待。</li></ul><p>给出使用demo：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//得到全局dispatch queue</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//生成Dispatch Semaphore 设置计数出事值为“1”。保证只有1个线程可以访问NSMutableArray类对象。</span></span><br><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> * array = [[<span class="built_in">NSMutableArray</span> alloc]init];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"><span class="comment">//等到计数值 &gt;= 1</span></span><br><span class="line">dispatch_semaphore_wait(seamphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当Dispatch Semaphore的计数值 &gt;= 1时，会将其计数值 减1。dispatch_semaphore_wait返回。</span></span><br><span class="line"><span class="comment">//此时计数值恒为0。保证了可访问array的线程只有1个，保证了数据的安全性</span></span><br><span class="line">[array addObject:[<span class="built_in">NSNumber</span> numberWithInt:i]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有通过wait函数执行到这里的话，计数值将+1,此时，会由最先等待的线程执行，知道计数值到1之后</span></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放semaphore</span></span><br><span class="line">dispatch_release(semaphore);</span><br></pre></td></tr></table></figure><h3 id="执行一次">执行一次</h3><p>常用于初始化操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="读取大文件的操作">读取大文件的操作</h3><p>当读取一个很大的文件时，如果一开始能够将文件分割成多个大小合适的文件。然后使用Global Dispatch Queue并行读取，将会加大效率。在GCD中通过Dispatch I/O 和 Dispatch Data</p><blockquote><p>dispatch_io_t dispatch_io_create( dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void (^cleanup_handler)(int error));</p></blockquote><ul><li>参数1：通道类型,DISPATCH_IO_STREAM读写操作按顺序依次顺序进行, DISPATCH_IO_RANDOM随机访问文件</li><li>参数2：文件描述符</li><li>参数3：dispatch queue</li><li>参数4：发生错误时用来执行处理的 Block</li></ul><blockquote><p>void dispatch_io_read( dispatch_io_t channel, off_t offset, size_t length, dispatch_queue_t queue, dispatch_io_handler_t io_handler);//读取操作</p></blockquote><ul><li>参数1：通道</li><li>参数2：要读取的信道的偏移量。若通道类型为DISPATCH_IO_RANDOM时，会忽略该参数。</li><li>参数3：从通道读取的字节数。指定size_max继续读取数据直到达到一个EOF。</li></ul><blockquote><p>void dispatch_io_set_low_water( dispatch_io_t channel, size_t low_water);//函数设置读取的最小值。</p></blockquote><blockquote><p>void dispatch_io_set_high_water( dispatch_io_t channel, size_t high_water);//函数设置读取的最大值。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block(2)-Block的内存管理</title>
      <link href="/2017/12/15/2017-12-15-Block(2)--Block%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/12/15/2017-12-15-Block(2)--Block%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一篇将上一篇文章<a href="http://www.jianshu.com/p/40e09f04f518" target="_blank" rel="noopener">Block(1)–block的实现原理</a>,略过的问题补充一下，同时这次从另外一个角度<strong>内存</strong>来看Block。这里先引用个很经典的关于block的内存管理的自测题<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/" target="_blank" rel="noopener">blockc测试题</a>，如果全部都对了，也明白其中原委，那就不必往下看了。</p></blockquote><h2 id="Block的存储位置">Block的存储位置</h2><p>关于Block我们从<a href="http://www.jianshu.com/p/40e09f04f518" target="_blank" rel="noopener">上篇文章</a>可以知道他的实质是一个结构体的实例，那这个结构体在什么位置呢？然后回顾一下之前有一个结构体为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> *isa;</span><br><span class="line"><span class="keyword">int</span> Flags;</span><br><span class="line"><span class="keyword">void</span> FuncPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的一个成员的含义上一次直接略过了。而这个isa成员变量，其实就是标记该成员变量在什么内存位置的。<br>它可以被赋值为以下3项：</p><ul><li>NSConcreteStackBlock(栈区）</li><li>NSConcreteGlobalBlock(全局区，也称数据区）</li><li>NSConcreteMallocBlock(堆区)</li></ul><p>内存四区示意图：</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA.png" alt=""></p><p>那么如何判断一个Block存储位置在哪？下面给出一个原则</p><blockquote><p>如果一个Block没有引用任何变量，那么这个变量一定在全局区。除此之外都会在栈区生成。而堆区的存在是由于其他原因导致的从栈区复制到了堆区。具体原因先往后看。</p></blockquote><p>我们知道栈区的变量是系统接管内存管理的，当超出作用域，该变量就会被销毁。Block分配在栈上，也是一样的道理，在超出作用域后，该Block会被销毁。为了解决这个问题，提供了一个从栈上复制到堆上的方法。这就有了NSConcreteMallocBlock类型。</p><h2 id="什么时候发生复制操作">什么时候发生复制操作</h2><ul><li>调用Block的copy方法实例方法</li><li>Block作为函数返回值</li><li>将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时</li><li>usingBlock的Cocoa框架内的方法</li><li>GDC中的API传递Block时</li></ul><p>除以上情况外都需要<strong>调用copy方法会复制</strong>。后面两个情况其实可以看出当作为函数参数进行传递的时候，不会进行复制，但是如果内部处理了参数，也会发生复制，就例如上面2个情况。</p><h2 id="循环引用的情况">循环引用的情况</h2><p>Block的复制特性使得他很容易造成循环引用。下面举个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>) init</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">blk = ^&#123;<span class="built_in">NSLog</span>(<span class="string">"self = %@"</span>, <span class="keyword">self</span>);&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里Block使用strong类型的id类型变量self，这样这个实例持有blk,blk也由于复制到了堆上而持有该实例。导致循环引用。解决办法只要使用一个__weak类型保存起self，然后再blk中使用即可。<br>举一反三，如果blk使用的不是self，但是是该实例的另一个id类型的成员变量。是由3者产生了循环用于。blk持有了该变量，变量持有self。而self持有blk。<br>上面说解决循环引用的都是在ARC环境下使用__weak修饰符。当在MRC下，使用__block说明符可以避免循环引用。因为在<strong>发生复制的时候，不会对__block说明符的变量信息retain</strong>在编码过程中，需要格外注意当时是否为ARC，以正确的使用__block说明符。</p><h2 id="block变量的存储位置">__block变量的存储位置</h2><p>上一篇文章结尾其实已经提到了当存在多个Block使用__block变量时，一个发生Block复制到了堆上，__block一定也会复制到堆上。当剩下的Block复制到堆上时，只增加__block变量的引用计数。这个和oc的内存管理方式是一脉相承的。再回头看看之前留下的问题，为什么需要一个指向自己本身结构体的指针，这样不是多此一举的原因是什么呢。<br>看下图：</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/__block%E5%A4%8D%E5%88%B6%E5%88%B0%E5%A0%86.png" alt=""></p><p>可以看出，当发生复制的时候，使用Block语法内的__block变量是存在堆上的__block实例，而在Block语法外使用该变量在复制前存在栈上的__block实例。从上图看出，在发生复制的时候只需要将栈上的__block实例的__forwarding指针指向复制到堆上的结构体。这个问题就解决了。</p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Block(1)-block的实现原理</title>
      <link href="/2017/12/05/2017-12-05-Block(1)--Block%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2017/12/05/2017-12-05-Block(1)--Block%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>上篇文章提到了<a href="http://www.jianshu.com/p/23a73e6b033a" target="_blank" rel="noopener">Objective-C的内存管理及实现</a>，这篇开始说一下很过语言都有过的概念，在JS里头叫闭包，在C++里头的Lambda拉姆达表达式，只不过在oc里头叫Block。篇幅有限，关于Block会分为两篇文章来讲述。这一篇主要从Block的实现的角度来讲。下一篇将从Block的内存角度来讲。</p><h2 id="Block的定义">Block的定义</h2><p><strong>带有自动变量（局部变量）的匿名函数</strong>。</p><blockquote><p>带有自动变量：也就是自己本身维护了一个变量。比如在一个循环内创建按钮，并监听按钮的点击事件。我们有三个方式可以做到：</p></blockquote><ul><li>将button的id作为参数作为传递</li><li>创建一个类，不断实例化维持id和回调的唯一性</li><li>可以<strong>使用Block</strong></li></ul><p>从上面看，其实每个方法都是为了解决每次循环内都维持每个button和回调一一对应。使用Block何乐而不为。那么它是如何带有*自动变量的？*先继续往下看。</p><blockquote><p>匿名函数</p></blockquote><p>在C语言中，函数是必须有函数名。<code>int func (int i)</code>。这里有同学可能说我定义成函数指针，例如这样：<code>int result = (*funP)(10)</code>就不需要命名了，其实如果你要实现这个函数指针的功能呢还是逃不过命名的规范的,<code>int (*funP)(int) = &amp;func</code>,不赋值是取不到函数地址的。<strong>而Block可以省略了函数名</strong>。对于一些简单的回调函数，这还是很方便的。<em>其实命名有时候会比写逻辑头疼</em>。</p><h3 id="截获自动变量">截获自动变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[block] i = %d, str = %s"</span>,i, str);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    i = <span class="number">999</span>;</span><br><span class="line">    str = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"i = %d, str = %s"</span>,i, str);</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/Block%E6%88%AA%E8%8E%B7%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F.png" alt=""><br>编译运行后结果会发现，之后的对变量i 和 str的赋值并不会影响到blk。也是在blk创建的时候，已经截获了该变量的值，<strong>保存在自己的自动变量中</strong>。</p><h3 id="block说明符">__block说明符</h3><p>上面提到Block可以在创建的时候截获变量，并保存起来。但是一旦保存起来，<em>是不允许在Block内部对该变量进行修改的</em>,如果需要在Block内部的修改外部变量的值，那么需要加上__block说明符。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"[block] i = %d, str = %s"</span>,i, str);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">999</span>;</span><br><span class="line">    str = <span class="string">"world"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"i = %d, str = %s"</span>,i, str);</span><br><span class="line">    blk();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/__block%E5%8F%98%E9%87%8F.jpg" alt=""></p><p>从结果可以看出，可以直接修改附加了__block的说明符的变量i的值。<br><strong>【Tips】截获变量的一些提示</strong></p><ul><li>截获的变量是一个对象。直接赋值当然报错，但是使用这个变量，调用变更该对象的方法是可以的</li><li>Block不支持对<code>const char str[] = &quot;hello&quot;</code>这样的数组进行截获。但是支持<code>const char *str = &quot;hello&quot;</code>。有用到的话，可以指针解决该问题了。</li></ul><h2 id="Block实质">Block实质</h2><p>先写一个最简单的Block：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"hello world"</span>);&#125;;</span><br><span class="line">blk();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>clang -rewrite-objc</code>,可以将代码含有bolck转换成C++源码,这里先将上一节*__block*的代码进行转换。我会将其拆分来看，在适当的地方加上注释。结合上注释还是可以理解的<br>我们先看这个main函数被解析成什么样子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//原函数的三句话在转换成CPP后也是3句话</span></span><br><span class="line"><span class="comment">//定义了一个block</span></span><br><span class="line"> <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"> <span class="comment">//调用blk</span></span><br><span class="line"> ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">​``` c++</span><br><span class="line">从定义和调用两个处语句中，第一眼感觉是会被各类中函数指针类型转换搞蒙圈.但是其中有很多的类型转换经过下面的分析是可以简写的。可以看到这里面有：</span><br><span class="line"></span><br><span class="line">- __main_block_impl_0类型</span><br><span class="line"></span><br><span class="line">- __main_block_func_0类型</span><br><span class="line"></span><br><span class="line">- __main_block_desc_0_DATA类型</span><br><span class="line"></span><br><span class="line">- __block_impl类型</span><br><span class="line"></span><br><span class="line">*带着这几个类型分别是什么含义的问题先往下看：**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### __main_block_impl_0类型</span><br><span class="line"></span><br><span class="line">​``` c++</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先看看这个结构体类型，包含了2个成员变量，和一个自己的都构造函数。<br><code>__block_impl</code><br><strong>第一个成员</strong>：<code>__block_impl</code>这个结构体至少有一下成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span> *isa;</span><br><span class="line"><span class="keyword">int</span> Flags;</span><br><span class="line"><span class="keyword">void</span> FuncPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类型在后面说到block的内存位置的时候再详细说。这里先略。<br><code>__main_block_desc_0</code><br><strong>第二个成员</strong>：从名字上来看可以知道是一个关于结构体的描述，内部结构是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>其结构为版本升级所需要的区域，和Block的大小。<br><code>__main_block_impl_0</code><br><strong>第三个成员</strong>：<code>__main_block_impl_0</code>的构造函数，参数列表中传入了3个参数。一个是函数指针，由<code>__block_impl</code>结构体中的FuncPtr接收。一个是<code>__main_block_desc_0</code>结构体类型变量，用于初始化其第二个成员变量Desc。还有一个标志位，由<code>__block_impl</code>结构体中的Flags接收。注意到<code>__block_impl</code>还有一个isa成员变量跟构造函数参数并无关系，直接设置成为了_NSConcreteStackBlock。这个也会在后面说到block的内存位置的时候再详细说。这里继续略过。</p><p>从main函数来看，我们创建的blk的本质就是这个结构体经过类型转换得来的。那么这里面保存了要执行这个block的基本参数。首先block的函数体保存在哪？</p><blockquote><p>__main_block_func_0类型</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"hello world"</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>而这个参数正是上面__main_block_impl_0构造函数的第一个参数。</p><p>再回头看看main函数里关于blk的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br></pre></td></tr></table></figure><p>省略掉类型转化则可以简化成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = __main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA)</span><br></pre></td></tr></table></figure><p>所以__main_block_impl_0结构体的实例，就是该blk的本质。</p><h2 id="Block的截获变量的实现">Block的截获变量的实现</h2><p>这里先不讨论关于截获变量并且进行修改的部分。只说截获自动变量这一部分。我们给之前的代码在创建Block之前添加一个变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"%d"</span>，i);&#125;;</span><br><span class="line">blk();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们通过<code>clang -rewrite-objc</code>进行经换会发现在__main_block_impl_0结构体中，其成员变量多变成了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> i;<span class="comment">//新添加的一个成员变量</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> i，<span class="keyword">int</span> flags=<span class="number">0</span>): i (_i) &#123;<span class="comment">//构造函数多了一个i的参数，</span></span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">    i = <span class="number">10</span>;<span class="comment">//i初始成10；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改过后的__main_block_func_0内部使用i时， 直接使用指向__main_block_impl_0结构体的指针值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> i = __cself-&gt;i;<span class="comment">//使用指针直接取值</span></span><br><span class="line"> <span class="built_in">printf</span>(i);         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看，在<strong>Block声明之前的所有局部变量会被Block对应的结构体实例保存在其内部成员中</strong>，这样也就解释了为了什么一旦截获，Block本身不能被修改该变量的值，<strong>此时两个变量也位于不同的内存中了</strong>。<br>由于在截获变量时，是将值传递给结构体实例进行保存，当传递一个数组类型的变量时，会出现数组类型的变量赋值给数组类型数组类型变量,在C语言的这样是不规范。这就验证了<strong>截获数组会导致编译报错的问题</strong>。</p><h2 id="block说明符的实现">__block说明符的实现</h2><p>前面说到的截获变量是通过将外部局部变量保存在结构体实例中实现的。那么如何做到使用了__block就可以修改被截获的变量呢？</p><p>对于全局变量（全局变量、全局静态变量）可以直接访问和修改，这里就不多说了。而对于静态变量来说，也只需要保存改静态变量的指针就可以达到要求。这里主要讨论的还是局部变量。那么如果对于局部变量也采用保存指针的方式进行访问修改，那么__block的说明符似乎就多此一举了。为什么没有这么做？</p><p>其实，在Block截获变量后，很有可能被截获的变量已经超出了它的作用域。如果使用了一个已经超出作用域的指针，是肯定会出现非法访问内存的错误的。那么__block是如何解决的？<br>同样，在原来的代码上加给<code>int i</code>加上__block说明符后，并且在block内修改i值。然后进行C++转换。只贴比较关键的转换后的代码。<br>先是看到多了一个结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_i_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看main函数__block int i = 10;转换后成了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_i_0 *)&amp;i, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_i_0), <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>会看到之__block int i变成了一个结构体。也就是说，__block 对应结构体__Block_byref_i_0，这个结构体内部保存了一个变量i，其中还有一个指向结构体本身的指针<code>__Block_byref_i_0 * __forwrading</code>。<br>然后再看修改这个i值的函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line"></span><br><span class="line">  __Block_byref_i_0 *i = __cself-&gt;i; <span class="comment">// bound by ref</span></span><br><span class="line">  (i-&gt;__forwarding-&gt;i) = <span class="number">12</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,(i-&gt;__forwarding-&gt;i));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>从上面的实现来看，让Block的结构体实例持有了__block对应的结构体实例的指针，然后通过这个指针访问他自己的__block结构体内一个指向自身的指针，再通过这个这个指向自己的指针访问需要修改的变量i;</p></blockquote><p>为什么要这么复杂。要看懂上一段话要多读几遍，再看看下面这幅图会理解的更好点：</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/__block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt=""></p><p>__block结构体并不在Block的结构体中，而是保存了一个指向他自己的变量，这样独立出来，通过结构体实例来维护一个指针，再通过指针访问截获的变量。保证了多个Block可以使用同一个__block变量。<br>而为什么不采用一个直接指向__block的指针来访问变量i，而是采用了一个指向自己的变量。这里先简单的抛出一个概念<strong>Block可存储在堆区，栈区，全局区，栈区和堆区会发生复制的操作</strong>，关于这个将会在下一篇文章《Block的内存管理》继续阐述。暂时只说个大概：</p><blockquote><p>当存在多个Block使用__block变量时，一个发生Block复制到了堆上，__block一定也会复制到堆上。这样只要保证栈区的__forwarding变量在复制后指向的是堆上的结构体实例。就实现了可以同时访问堆上和栈上的__block变量。<br>如果直接通过指针访问对应的变量i，在发生复制的时候，将会出现非法访问问题。</p></blockquote><p><em>上班忙成狗，下周再抽时间把本篇略过的部分，关于Block的存储区域和内存管理的问题讲清楚。</em></p>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C的内存管理</title>
      <link href="/2017/11/18/2017-11-18-Objective-C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2017/11/18/2017-11-18-Objective-C%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>前段时间捡起来<a href="http://www.ituring.com.cn/book/1023" target="_blank" rel="noopener">Objective-C高级编程：iOS与OS X多线程和内存管理</a>，上面的链接可以直接看第一章。然后朋友开玩笑说“现在看OC就跟1949年加入国名党一样啊”。不吹不黑，OC还是蛮有意思的。即便apple的审核让人叫苦不迭。技术单纯为技术。OC如同它所属公司一样，是优雅的语言。</p><h2 id="内存管理概述">内存管理概述</h2><p>内存管理，其目的就是以为了能够<strong>快速分配内存，并且适当的时候释放并且回收内存</strong>。从内存四区来看只有<strong>堆区</strong>的内存是可以程序来申请和释放的。那么Objective-C是如何进行内存管理的？常见的的方式有如下三种</p><ol><li><p>手动内存管理（MRC）-- 手动增加和减少引用计数</p></li><li><p>自动引用计数（ARC）</p></li><li><p>自动垃圾回收</p></li></ol><p><em>自动垃圾回收是Mac上的应用才支持，这里就不做讨论了，(自己也没搞明白）</em></p><h2 id="引用计数">引用计数</h2><blockquote><p>引用计数：顾名思义就是引用了就加一个计数，不用了就减少一个计数。</p></blockquote><h3 id="内存管理基本规则">内存管理基本规则</h3><ul><li><strong>自己生成的对象，自己持有</strong></li></ul><p>所有以<strong>alloc/new/copy/mutableCopy</strong>开头的方法生成对象都为自己持有。<em>注意是驼峰命名方式的哈</em></p><ul><li><strong>不是自己生成的，自己可以持有</strong></li></ul><p>不是自己持有的对象，需要加retain进行持有。比如<code>id obj = [obj0 object]</code>取得了对象，但不持有。<code>[obj retain]</code>之后才可持有这个对象。此时引用计数+1。</p><ul><li><strong>自己不用的对象，自己需要释放</strong></li></ul><p>release释放自己不需要的对象内存<code>[obj release]</code></p><ul><li><strong>不是自己持有的对象，无法释放</strong></li></ul><p>当上面的obj 在retain后立马执行<code>[obj release]</code>后，obj不在持有对象，此时在次执行<code>[obj release]</code>会因为访问已经废弃的对象导致奔溃。</p><h3 id="引用计数存在什么地方？">引用计数存在什么地方？</h3><p>采用了哈希表（散列表）进行存储，表键值是内存地址的散列值。这样处理能够在追溯到各个内存块的位置。</p><h3 id="autorelease">autorelease</h3><p>这个名称看起来就像自动释放，有点内存自动管理的意思。但是并不是，实际上，在ARC的开发环境下，是不允许对某个对象发送<code>[obj autorelease]</code>消息的。<br>顾名思义为自动释放，在C的语法中，局部变量也是在超出作用域就自动被废弃。这也正是autorelease的作用。当一个向一个对象发送<code>autorelease</code>后,在超出作用域的时候将被自动释放，也就是会调用release方法。而这个作用域和局部变量不同的是，该作用域可以有我们控制起来啊。生成对象<code>pool = [NSAutoreleasePool alloc] init]</code>,废弃pool对象<code>[pool drain]</code>，这中间调用autorelease方法，在废弃pool对象的时候，所有会自动调用release方法。</p><blockquote><p>NSRunLoop每次循环会创建和废弃NSAutoreleasePool对象</p></blockquote><blockquote><p>不废弃NSAutoreleasePool对象，将不会废弃已发送autorelease消息的对象。</p></blockquote><p>由于在作用域结束的时候，需要释放，结合上面的规则不是自己持有的对象，无法释放。也可得知<strong>autorelease可以持有不是自己生成的对象</strong>。</p><h2 id="自动引用计数（ARC）">自动引用计数（ARC）</h2><p>知道了引用计数，之前的手动的添加retain、 release太容易出错了。因此在iOS5.0系统和OSX10.7系统之后，在Xcode4.2版本以上可以使用这一特性。降低程序奔溃的同时，还减少了工作量。美滋滋。苹果官方的说法是：<strong>由编译器进行内存管理</strong>，也就是编译器【clang (LLVM编译器) 3.0以上】就可以完成。实际上在这个基础上还需要Objective-C运行库的协助。</p><h3 id="对象类型和id类型必须附加所有权修饰符">对象类型和id类型必须附加所有权修饰符</h3><ul><li><strong>__strong</strong></li><li><strong>__weak</strong></li><li><strong>__unsafe_unretained</strong></li><li><strong>__autoreleasing修饰符</strong></li></ul><ol><li><p>__strong<br><strong>是id类型和对象类型默认的所有权修饰符</strong>，修饰的变量在超出变量作用域的时候，该变量会被废弃，其被赋予的对象会执行release方法而被释放。<strong>强引用就是在该引用失效后，引用的变量也要被释放</strong>,只要有任何__strong类型的变量指向对象A，ARC就不会销毁它（A）。如下图中<img src="https://gitee.com/zzRong/MyPics/raw/master/img/strong%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p></li><li><p>__weak<br>如果相互持有对方的引用，如果这时候使用__strong修饰符就会造成<em>循环引用</em>。但是使用__weak修饰符可以避免这个问题。因为*__weak不会持有对象的实例*，在超出变量作用域之后，其引用的对象就立即被释放,__weak所指向的对象B，只要没有其他__strong指向该对象（B），ARC会销毁它（B）。这里同样给出一个示意图：</p></li></ol><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/weak%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p><p>这里变量b是weak类型。当变量a不在持有对象A的时候，对象A将被销毁，说明weak变量是不会持有其指向的对象。</p><ol start="3"><li><p>__unsafe_unretained<br>名称上可以看出是一个不安全的不会增加引用计数的所有权修饰符，也就是和weak一样，不会持有所引用的对象。这个也是在__weak还未出现的时候，用来替代__weak修饰符的。但是区别在于：<strong>__unsafe_unretained并不会和__weak一样将指针自动置为nil，因此会造成野指针问题</strong>。访问野指针是会crash的，如今有了weak，还是少用这个修饰符吧。</p></li><li><p>__autoreleasing<br>在MRC下我们可以使用NSAutoreleasePool,并且向对象发送<code>autorelease</code>消息，但在ARC下这样做事不允许的。如何在ARC下使用呢。于是就有了，__autoreleasing 修饰符。它就等价于向对象发送<code>autorelease</code>消息。而使用<code>@autoreleasepool{... ...}</code>等价于NSAutoreleasePool的生成释放等。<br>默认情况下，会自动的给id类型和对象类型附加上__autoreleasing修饰符。编译器会检查是否<strong>alloc/new/copy/mutableCopy</strong>开始的方法名进行对象的生成，如果不是的话，将会自动添加到autoreleasepool中，这样就可以保证了不是自己生成的对象，也能持有。这其中的特例为<strong>init</strong>开头的方法,要求比较严格，并不会注册到autoreleasepool中。</p></li></ol><h3 id="关于init">关于init</h3><p>以init开头的方法要求有：</p><ol><li><p>必须是实例方法。</p></li><li><p>必须返回对象。</p></li><li><p>返回的对象不会注册到autoreleasepool中。</p></li></ol><p>常见用法是对alloc方法返回的对象进行初始化操作，然后返回该对象。那么在ARC环境下，<strong>默认注册到autoreleasepool中的情况</strong>有那些呢？根据前面介绍的其实总结到</p><ol><li>作为返回值的时候，在函数作用域结束之后，该对象仍然被持有，这样可以做到延后释放。</li><li>使用__weak修饰符的变量，在变量作用域结束的时候，变量会被释放，将不能被正常使用，因此会自动注册到autoreleasepool中。</li><li>id的指针类型，或者对象的指针类型的变量会被默认附加上__autoreleasing修饰符。这个和id obj 会默认附加上id __strong obj; 这里存在一个问题就是我们知道strong weak这样的修饰符会保证id类型的变量初始化为nil，但是如果是id*却不被保证。也就是说需要手动设置为nil，全部展开应该是这样的的：<code>NSObject __autoreleasing * __strong *array = nil</code>。</li></ol><h2 id="ARC的实现">ARC的实现</h2><h3 id="strong">__strong</h3><p>先写一段一下的代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import<span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obg = [[<span class="built_in">NSObject</span> alloc]init];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后进行汇编输出后<img src="https://gitee.com/zzRong/MyPics/raw/master/img/__strong%E6%B1%87%E7%BC%96%E8%BE%93%E5%87%BA.png" alt=""><br>会发现有一句 callq _objc_storeStrong。而这个方法的原型是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//location引用对象指针的地址</span></span><br><span class="line"><span class="comment">//obj 对象本身</span></span><br><span class="line"><span class="keyword">void</span> objc_storeStrong(<span class="keyword">id</span> *location, <span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> prev = *location;</span><br><span class="line">    <span class="keyword">if</span> (obj == prev) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    objc_retain(obj);</span><br><span class="line">    *location = obj;</span><br><span class="line">    objc_release(prev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的基本逻辑可以看出，如果和之前是同一个引用则直接return，否则将进行retain操作。然后释放之前的引用。这正是强引用的实际效果。<br>如果是引用的是一个不是自己生成持有的对象的话呢，例如 <code>[NSMutableArray array]</code>函数这里就不贴图了，同样的方法会发现多了·<code>callq_objc_retainAutoreleasedReturnValue</code>这么一个函数，与之配对的是_objc_autoreleaseReturnValue。而这对函数主要的作用是在优化。正常情况下是需要将注册到autoreleasepool中的。然后再返回。如果调用后紧接着调用了_objc_retainAutoreleasedReturnValue，将不会<strong>注册到autoreleasepool中，而是自己返回对象，减少了一次主持autoreleasepool的操作</strong>。</p><h3 id="weak">__weak</h3><p>有上头的objc_storeStrong方法，也就有与之对应的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_storeWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line">    </span><br><span class="line"> retry:</span><br><span class="line">    oldObj = *location;</span><br><span class="line">    oldTable = SideTable::tableForPointer(oldObj);</span><br><span class="line">    newTable = SideTable::tableForPointer(newObj);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">if</span> (*location != oldObj) &#123;</span><br><span class="line">        OSSpinLockUnlock(lock1);</span><br><span class="line">/<span class="meta">#<span class="meta-keyword">if</span> SIDE_TABLE_STRIPE &gt; 1</span></span><br><span class="line">        <span class="keyword">if</span> (lock1 != lock2) OSSpinLockUnlock(lock2);</span><br><span class="line">/<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldObj) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newObj) &#123;</span><br><span class="line">        newObj = weak_register_no_lock(&amp;newTable-&gt;weak_table, newObj,location);</span><br><span class="line">    &#125;</span><br><span class="line">    *location = newObj;</span><br><span class="line">   <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">return</span> newObj</span><br></pre></td></tr></table></figure><p>可以看出首先获取到新对象和内部维护的一个与之新旧对象相关的SideTable表。然后移除老对象的指向信息。然后将指针指向新对象。最后返回这个新对象。从中可证实weak弱引用的特点。因此每次创建需要去查表。而同时一个对象可以被复制给多个变量，当weak变量多了之后，每次创建和销毁都将带来大量的查表工作。会消耗一定CPU资源。因此，<strong>一般只在避免循环引用的情况下才使用weak</strong></p><blockquote><p>autoreleasing 在__strong那里的_objc_retainAutoreleasedReturnValue就说过，不赘述了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Objective-C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决访问GitHub访问慢问题</title>
      <link href="/2017/10/16/2017-10-17-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEGitHub%E8%AE%BF%E9%97%AE%E6%85%A2%E9%97%AE%E9%A2%98/"/>
      <url>/2017/10/16/2017-10-17-%E8%A7%A3%E5%86%B3%E8%AE%BF%E9%97%AEGitHub%E8%AE%BF%E9%97%AE%E6%85%A2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>早上到公司发现github不能正常打开，整个页面没有任何资源，只有白底蓝，实在是难受。网上搜一下发现很多关于这个问题的答案，但是都是直接贴出来了一些hosts文件。授人以鱼不如授人以渔。<em>访问网站一般是先访问主站，然后进行加载资源</em>，那么我们来看如何按着这个思路解决这个问题。</p><h2 id="扫盲hosts文件">扫盲hosts文件</h2><p>它是一个没有扩展名的系统文件，能够将某个域名（网址）对应的IP建立一种联系，当用户访问其域名的时候，会直接找到对应的IP地址打开网址，如果找不到的话，才会将域名提交到DNS域名解析服务器。</p><blockquote><p>现在上述域名会链接失败，我们可以利用工具找到其可以使用的IP地址，然后通过hosts文件进行关联，这样就解决问题了</p></blockquote><h2 id="解决方案">解决方案</h2><ol><li><p>于是打开chrome控制台，能发现大多<strong><a href="http://assets-cdn.github.com" target="_blank" rel="noopener">assets-cdn.github.com</a></strong>这个域名报连接失败。而需要请求的域名有如下几个：<img src="https://gitee.com/zzRong/MyPics/raw/master/img/gitHubError.jpg" alt=""></p></li><li><p>打开<a href="http://tool.chinaz.com/dns/" target="_blank" rel="noopener">站长之家-DNS查询</a>，如下图所示，<a href="http://xn--assets-cdn-t79ph380d.github.com" target="_blank" rel="noopener">输入assets-cdn.github.com</a>，多检测几次，找一个TTL稳定比较小的IP</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/DNS%E6%9F%A5%E8%AF%A2.jpg" alt=""></p></li><li><p><strong>mac环境</strong>文件位于**/private/etc/<strong>下，<strong>windows环境</strong>文件文件位于</strong>C:\Windows\System32\drivers\etc\**下，打开文件并在在底部加入一行</p></li></ol><blockquote><p>151.101.76.133<a href="http://assets-cdn.github.com" target="_blank" rel="noopener">assets-cdn.github.com</a></p></blockquote><p>其他域名也是按照上面两个步骤。最后完成后的hosts文件如下:</p><p><img src="https://gitee.com/zzRong/MyPics/raw/master/img/github_hosts.jpg" alt=""></p><ol start="4"><li>重启浏览器，妥妥的。</li></ol><p><em>以此类推，其他网站原理也是一样的</em></p><p>反正还是科学上网解决一切。哎哎。</p>]]></content>
      
      
      <categories>
          
          <category> 日常填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git分支管理策略与场景应用</title>
      <link href="/2017/10/16/2017-10-16-Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/"/>
      <url>/2017/10/16/2017-10-16-Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<p>Git的优势在于分支功能。但自身对各个目录的访问权限的限制却有点违背Git的设计初初衷了。如果你真的想要这么做，请移步<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">gitolite</a>。这里提倡的Git使用方式是组织内部透明，允许任何人查看和查阅代码。保持正确的使用规范来进行分支管理。其次，需要有一个概念是，每个clone下来的都是一个完整的代码库。</p><h2 id="总览">总览</h2><ul><li>master： 发布版本主分支</li><li>dev：日常开发主分支</li><li>feature ：具体功能分支</li><li>release ：master的测试分支</li><li>hotfix ：线上bug分支</li></ul><h2 id="主要分支">主要分支</h2><p>包含master和dev这两个分支放在一起有区别其他分支是因为应该是一直存在的。<br>master主要用于经过测试后可用于发布上线的的版本分支。<br>dev是开发完成后的功能版本分支，当所有功能开发完成后会合并到dev分支，当dev分支测试完成后，将dev分支合并到master分支。<br>其实这样就可以实现基本的团队开发模型。但是在实际开发中，只有这两个分支是肯定不够的。下面考虑下面几个场景</p><h2 id="辅助分支与对应场景应用">辅助分支与对应场景应用</h2><h3 id="feature-xxx新功能开发使用">feature-xxx新功能开发使用</h3><p>场景1：每次开发一个新功能的时候，大多数情况都是需要一些试验性的代码。如果直接在dev环境下进行新功能开发，即便项目拥有很低的耦合性，但是依旧会把原来的版本弄乱。除了试验性的代码外还有很多种情况，比如万一这个功能做到一半，产品经理改需求了（程序和产品有不可调和的矛盾）。这时候那如何解决呢？</p><p>为了解决这个问题，如果在开发的时候从dev上fork一个新分支，进行新功能开发，这就是feature分支，命名上可以加上功能名称标志，方便阅读。就算这个功能需要被砍掉。只要没有合并到dev上就可以直接删除掉。</p><blockquote><p>git branch -D feature-xxx<br>-D是强制删除的分支，因为没有合并的分支git是不允许你使用-d来直接删除的。如果已经合并到了dev，版本回退到上一版本也就好了。不过这就是该分支需要关心的啦</p></blockquote><h3 id="release-预发布测试使用">release 预发布测试使用</h3><p>场景2：dev分支开发完成后，到发布期间还需要测试团队A进行一些小的细节测试（并不是重大BUG）。测试期间开发团队又需要继续开发下个版本（程序员黑脸吐槽：版本接版本，版本何其多啊…）。为了不影响待发布的版本，又要继续开发下个版本管理呢?</p><p>该分支从dev分支fork而来。主要是为了发布新版本做准备。在此分支上可以进行一些细微的修改。常见的使用方式是在创建release分支时候根据当前项目版本号规则创建一个release-xxx。而对于这个版本不发布的功能则不需要合并的dev分支上，而是应该在当前版本的dev上创建好了release分支之后，再去合并新的功能分支。这样当release分支测试完毕后，可以合并到master和dev上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b release-1.2 devlop//从dev中创建一个分支</span><br><span class="line">//...</span><br><span class="line">//允许修改一部分bug，修改工程配置文件的版本号等小问题</span><br><span class="line">//...</span><br><span class="line">git commit -a -m "添加版本号" //提交</span><br><span class="line"></span><br><span class="line">git checkout master//切换到主分支</span><br><span class="line">git merge --no-ff -m "preRelease-1.2" release-1.2//合并到发布上线版本的主分支</span><br><span class="line"></span><br><span class="line">git branch -d release-1.2//确定没有冲突后删除release-1.2分支</span><br><span class="line">git tag -a 1.2 //完成版本合并后 打上标签</span><br></pre></td></tr></table></figure><h3 id="hofix-xxx-Bug热修复分支">hofix-xxx Bug热修复分支</h3><p>场景3：当release预发布版本经过测试后并没有什么bug,于是合并到master并且上线。（大家都懂的，线上总是能给大家惊喜），线上bug出现了。而这个时候dev分支又已经合并了新的feature分支。而且你手头上可能还正在开发新的功能。那么我们该如何进行快速线上bug的修复？</p><p>首先该分支是从master分出来的，这样可以保证和线上环境一样，排除当前不稳定的dev环境。当然，这时候需要提升正确的版本号。修复完成后，需要合并到mater分支和dev分支。<strong>特殊情况：当存在release版本的话，则不需要同步到release版本，然后当release版本完成后再合并到dev分支上</strong>。这样也就保证多了hotfix的修复能合并到master线上版本，也能保证下个版本不会继续再出现这样的BUG。</p><p><strong>参考文章：</strong><br><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">Git教程</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略</a></p><p>**Tips：**因为今天不小心手贱把一个文件删除了，然后直接chekout带中文名在bash里头显示的一大串编码真是蛋疼，于是度娘到了下面的这个方法。<br><a href="http://blog.csdn.net/wuzhimang/article/details/52652687" target="_blank" rel="noopener">git 恢复删除的所有文件（含中文）</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常填坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
